<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hux Blog</title>
    <description>关于程序与设计、黑客与画家 | 黄玄，Web &amp; Mobile Lover，Software Engineer，UX Designer | 这里是 @Hux黄玄 的个人博客，与你一起发现更大的世界。</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 02 Feb 2019 12:07:06 +0800</pubDate>
    <lastBuildDate>Sat, 02 Feb 2019 12:07:06 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>Welcome to Jekyll!</title>
        <description>&lt;p&gt;You’ll find this post in your &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code class=&quot;highlighter-rouge&quot;&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Tom'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints 'Hi, Tom' to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;https://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;

</description>
        <pubDate>Sat, 02 Feb 2019 11:39:47 +0800</pubDate>
        <link>http://localhost:4000/jekyll/update/2019/02/02/welcome-to-jekyll/</link>
        <guid isPermaLink="true">http://localhost:4000/jekyll/update/2019/02/02/welcome-to-jekyll/</guid>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
      <item>
        <title>程序员中的梦想家</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;本文首发于我的知乎专栏 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/38722466&quot;&gt;The Little Programmer&lt;/a&gt;，转载请保留链接 ;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;有一类程序员是 visionary 型的，为了实现一些超前的 idea，绕过某些技术的限制，他们写的 code 晦涩高深得只有他们自己能懂，做出来的 tool 看上去很美好结果处处是坑出了 bug 根本没法查，但正是这类人不断创造出新的东西，在洗礼之后成为一个个 big thing。&lt;/p&gt;

&lt;p&gt;我每周都要被 infra 的坑 block 得无法工作几次搞得非常沮丧，后来我发现这个锅除了要扔给 FB 外，还有一大半要扔给我周围这群 visionary 的同事们，我工作直接需要接触到的区区五六个人，发起/创造了 Infer, React, Reason, ReasonReact, BuckleScript…&lt;/p&gt;

&lt;p&gt;所以这大概就是见证/参与这些 idea 成长的代价吧，也意识到这些东西不是在刚开始就像后来大家接受流行时那么美好的。React 发布 5 周年生日时回放 Jordan/Tom 2013 年第一次对外发布 React/JSX 的视频。我问 Jordan 说你后来怎么没再去分享了。他说你不知道我那天讲完下来被所有听众指着批评。React 第一次在内部使用是 2011 年在 news feed，然后是 2012 年 instagram (pete hunt)，所以这个时间其实很长很长。&lt;/p&gt;

&lt;p&gt;很多人（包括我）都会经常觉得 XYZ 新事物跟老东西比太新、太不成熟、体验太不好、想要解决的问题太多、解决方案太 overkill、然后就没有然后了，但其实说不定你在看的这个就是 next big thing 呢。这些梦想家们 vision 里的 big picture 太大了，有的人可能在半个 picture 出来的时候就可以看出来了，有的人则可能要等到整个 picture 都快填满了才看得出来。&lt;/p&gt;

&lt;p&gt;如果不是因为 Ads/Messenger 的坑深 React/Reason/Flux 也就不会在这里诞生了，&lt;/p&gt;

&lt;p&gt;如果不是因为 Facebook 的坑深 GraphQL/Infer/Hack/Flow/Buck 也就不会在这里诞生了。&lt;/p&gt;

&lt;p&gt;正是有一群开垦者不怕坑深才使得各种 idea 成为了大家手上好用的 tool 啊。&lt;/p&gt;

&lt;p&gt;梦想家程序员们的工作价值于实干主义的程序员，总是很容易在过程中被低估、忽视，或是得不到尊重。而又在流行之后被神化，仿佛是那个人早已洞察一切一样。其实梦想家的工作，也是一点点累加，一点点迭代起来的。他们也需要伯乐和追随者的支持和帮助。&lt;/p&gt;

&lt;p&gt;Chenglou 这个人总是在巨兴奋与巨沮丧之间切换，这段时间下来，我开始能感受这种情绪的来源了。&lt;/p&gt;

&lt;p&gt;他总是用一句话来总结他回答我的吐槽、抱怨、疑问、惊叹，我就用这句话来结尾好了：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;“Welcome to the producer side!”&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 30 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/06/30/dreamer/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/30/dreamer/</guid>
        
        <category>Facebook</category>
        
        <category>生活</category>
        
        
      </item>
    
      <item>
        <title>「知乎」如何证明不可计算的函数比可计算的函数多？</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;这篇文章转载自&lt;a href=&quot;https://www.zhihu.com/question/51508063/answer/275401076&quot;&gt;我在知乎上的回答&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;严谨的证明的话，可以使用「形式语言」（&lt;a href=&quot;https://en.wikipedia.org/wiki/Formal_language&quot;&gt;Formal language&lt;/a&gt;）来证明：&lt;/p&gt;

&lt;p&gt;在可计算理论和计算复杂度理论中，每个「计算问题」都被描述为一个一个「形式语言」，即字符串的集合。比如对于判断一个图是否是无向连通图这个问题：我们可以写为一个描述所有无向连通图的集合：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;A = \{ \langle G \rangle \vert G \text{ is a connected undirected graph}\}&lt;/script&gt;

&lt;p&gt;由于图灵机只能接受字符串，所以这里的尖括号表示对图的「编码」。出于简单，我们全部使用现实计算机所使用的字母表
$\Sigma = \{0, 1\}$，所以「编码」即一个对象的二进制字符串描述。&lt;/p&gt;

&lt;p&gt;如果我们能构造出一个图灵机来「决定」这个「形式语言」，即可以判断一个「输入」是否属于这个集合（membership 与 non-membership），那么我们可以说我们用「图灵机」描述了一个「算法」来计算这个问题，而这个「计算问题」所对应的函数是「可计算的」，否则是「不可计算的」。（注 1）&lt;/p&gt;

&lt;p&gt;那么，如果我们有一个包含了所有「可计算函数」的集合，这个集合会有多大呢？&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;由于&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;所有「可计算函数」总有一个对应的「图灵机」来计算它&lt;/li&gt;
  &lt;li&gt;每一个「图灵机」都可以被「编码」为一个不同的 0、1 序列，比如 000，010…&lt;/li&gt;
  &lt;li&gt;0、1 序列、即二进制，总是可以被转换为一个十进制数的&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，我们这个集合实际上是与整数集 $Z$ 一样大（等势）的，我们把这个集合表示为 $\Sigma^{*}$。 易知 $Z$ 是「无穷可数（countably infinite）」的，所以我们有无穷可数个「可计算函数」（注 2）。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;而「计算问题」有多少个呢？&lt;/p&gt;

&lt;p&gt;这个问题可以等同于，我们有多少个形如 $\{000, 010\}$ 这样的 0，1 序列的集合？即 $\Sigma^{*}$ 这个集合有多少个子集？用数学语言描述就是求 $\Sigma^{*}$ 的幂集的势 $| P(\Sigma^{*})|$ 。&lt;/p&gt;

&lt;p&gt;由于 $\Sigma^{*}$ 与 $Z$ 是等势的，所以这个问题等价于求 $|P(Z)|$ 的大小。根据 &lt;a href=&quot;https://en.wikipedia.org/wiki/Cantor%2527s_theorem&quot;&gt;Cantor’s theorem&lt;/a&gt;，一个「无穷可数」的集合的幂集是「无穷不可数（uncountably infinite）」的。（注 3）&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;根据 &lt;a href=&quot;https://en.wikipedia.org/wiki/Cantor%2527s_theorem&quot;&gt;Cantor’s theorem&lt;/a&gt;，「无穷不可数集」要比「无穷可数集」大。&lt;/p&gt;

&lt;p&gt;同时，「无穷不可数集」减去「无穷可数集」后仍然是「无穷不可数集」。（注 4）&lt;/p&gt;

&lt;p&gt;所以，「不可计算函数集」，即「计算问题集」与「可计算函数集」的差，仍是「无穷不可数集」，仍比是为「无穷可数集」的「可计算函数集」大。&lt;/p&gt;

&lt;p&gt;因此，「不可计算的函数」比「可计算的函数」多。&lt;/p&gt;

&lt;p&gt;证毕。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;注：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;「&lt;a href=&quot;https://en.wikipedia.org/wiki/Computable_function&quot;&gt;可计算函数&lt;/a&gt;」是算法的直觉说法，「&lt;a href=&quot;https://en.wikipedia.org/wiki/Church%25E2%2580%2593Turing_thesis&quot;&gt;邱奇－图灵论题&lt;/a&gt;」猜想任何在算法上可计算的问题同样可以由图灵机计算。但图灵机并不是唯一的计算模型，其他计算模型包括「&lt;a href=&quot;https://en.wikipedia.org/wiki/Lambda_calculus&quot;&gt;Lambda 算子&lt;/a&gt;」、「$\mu$ - &lt;a href=&quot;https://en.wikipedia.org/wiki/%25CE%259C-recursive_function&quot;&gt;递归函数&lt;/a&gt;」等，它们在计算能力上都是与「图灵机」等价的。&lt;/li&gt;
  &lt;li&gt;证明「所有可计算函数」的集合是「无穷可数集」的方式有很多，只要找到任意一个与「自然数集」的「双射」即可&lt;/li&gt;
  &lt;li&gt;也可以直接用康托的对角线法（&lt;a href=&quot;https://en.wikipedia.org/wiki/Cantor%2527s_diagonal_argument&quot;&gt;Cantor’s diagonal argument&lt;/a&gt;）证明「所有计算问题」的集合是「无穷不可数集」&lt;/li&gt;
  &lt;li&gt;可以用反证法得证&lt;/li&gt;
  &lt;li&gt;知乎能用 LaTex 了好评&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Aleph_number&quot;&gt;Aleph Number - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Tue, 12 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/12/12/uncomputable-funcs/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/12/12/uncomputable-funcs/</guid>
        
        <category>知乎</category>
        
        <category>计算机科学</category>
        
        <category>计算理论</category>
        
        
      </item>
    
      <item>
        <title>「知乎」如何通俗地解释停机问题？</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;这篇文章转载自&lt;a href=&quot;https://www.zhihu.com/question/20081359/answer/275107187&quot;&gt;我在知乎上的回答&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我用 Python 伪代码来解释下，我觉得对这个问题有兴趣的应该都是有点编程基础的，所以直接上 code 应该是最容易的。&lt;/p&gt;

&lt;h2 id=&quot;背景知识&quot;&gt;背景知识&lt;/h2&gt;

&lt;p&gt;「停机问题」研究的是：是否存在一个「程序」，能够判断另外一个「程序」在特定的「输入」下，是会给出结果（停机），还是会无限执行下去（不停机）。&lt;/p&gt;

&lt;p&gt;在下文中，我们用「函数」来表示「程序」，「函数返回」即表示给出了结果。&lt;/p&gt;

&lt;h2 id=&quot;正文&quot;&gt;正文&lt;/h2&gt;

&lt;p&gt;我们假设存在这么一个「停机程序」，不管它是怎么实现的，但是它能够回答「停机问题」：它接受一个「程序」和一个「输入」，然后判断这个「程序」在这个「输入」下是否能给出结果：&lt;/p&gt;

&lt;div class=&quot;language-py highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;is_halt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;program&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# 返回 True  如果 program(input) 会返回
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 返回 False 如果 program(input) 不返回
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;（在这里，我们通过把一个函数作为另一个函数的输入来描述一个「程序」作为另一个「程序」的「输入」，如果你不熟悉「头等函数」的概念，你可以把所有文中的函数对应为一个具备该函数的对象。）&lt;/p&gt;

&lt;p&gt;为了帮助大家理解这个「停机程序」的功能，我们举个使用它的例子：&lt;/p&gt;

&lt;div class=&quot;language-py highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;halt&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_halt&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# 如果输入是 0，返回，否则无限循环
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;is_halt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 返回 True
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;is_halt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 返回 False
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;是不是很棒？&lt;/p&gt;

&lt;p&gt;不过，如果这个「停机程序」真的存在，那么我就可以写出这么一个「hack 程序」：&lt;/p&gt;

&lt;div class=&quot;language-py highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;halt&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_halt&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;program&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_halt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;program&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;program&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个程序说，如果你 &lt;code class=&quot;highlighter-rouge&quot;&gt;is_halt&lt;/code&gt; 对 &lt;code class=&quot;highlighter-rouge&quot;&gt;program(program)&lt;/code&gt; 判停了，我就无限循环；如果你判它不停，我就立刻返回。&lt;/p&gt;

&lt;p&gt;那么，如果我们把「hack 程序」同时当做「程序」和「输入」喂给「停机程序」，会怎么样呢？&lt;/p&gt;

&lt;div class=&quot;language-py highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;is_halt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;你会发现，如果「停机程序」认为 &lt;code class=&quot;highlighter-rouge&quot;&gt;hack(hack)&lt;/code&gt; 会给出结果，即 &lt;code class=&quot;highlighter-rouge&quot;&gt;is_halt(hack, hack)&lt;/code&gt;) 返回 &lt;code class=&quot;highlighter-rouge&quot;&gt;True&lt;/code&gt;) ，那么实际上 &lt;code class=&quot;highlighter-rouge&quot;&gt;hack(hack)&lt;/code&gt; 会进入无限循环。而如果「停机程序」认为 &lt;code class=&quot;highlighter-rouge&quot;&gt;hack(hack)&lt;/code&gt; 不会给出结果，即 &lt;code class=&quot;highlighter-rouge&quot;&gt;is_halt(hack, hack)&lt;/code&gt; 返回 ，那么实际上 &lt;code class=&quot;highlighter-rouge&quot;&gt;hack(hack)&lt;/code&gt; 会立刻返回结果……&lt;/p&gt;

&lt;p&gt;这里就出现了矛盾和悖论，所以我们只能认为，我们最开始的假设是错的：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这个「停机程序」是不存在的。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;意义&quot;&gt;意义&lt;/h2&gt;

&lt;p&gt;简单的说，「停机问题」说明了现代计算机并不是无所不能的。&lt;/p&gt;

&lt;p&gt;上面的例子看上去是刻意使用「自我指涉」来进行反证的，但这只是为了证明方便。实际上，现实中与「停机问题」一样是现代计算机「不可解」的问题还有很多，比如所有「判断一个程序是否会在某输入下怎么样？」的算法、Hilbert 第十问题等等，wikipedia 甚至有一个 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/List_of_undecidable_problems&quot;&gt;List of undecidable problems&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;漫谈&quot;&gt;漫谈&lt;/h2&gt;

&lt;p&gt;如果你觉得只是看懂了这个反证法没什么意思：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;最初图灵提出「停机问题」只是针对「图灵机」本身的，但是其意义可以被推广到所有「算法」、「程序」、「现代计算机」甚至是「量子计算机」。&lt;/li&gt;
  &lt;li&gt;实际上「图灵机」只能接受（纸带上的）字符串，所以在图灵机编程中，无论是「输入」还是另一个「图灵机」，都是通过编码来表示的。&lt;/li&gt;
  &lt;li&gt;「图灵机的计算能力和现代计算机是等价的」，更严谨一些，由于图灵机作为一个假象的计算模型，其储存空间是无限大的，而真实计算机则有硬件限制，所以我们只能说「不存在比图灵机计算能力更强的真实计算机」。&lt;/li&gt;
  &lt;li&gt;这里的「计算能力」（power）指的是「能够计算怎样的问题」（capablity）而非「计算效率」（efficiency），比如我们说「上下文无关文法」比「正则表达式」的「计算能力」强因为它能解决更多的计算问题。&lt;/li&gt;
  &lt;li&gt;「图灵机」作为一种计算模型形式化了「什么是算法」这个问题（&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Church%25E2%2580%2593Turing_thesis&quot;&gt;邱奇－图灵论题&lt;/a&gt;）。但图灵机并不是唯一的计算模型，其他计算模型包括「&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Lambda_calculus&quot;&gt;Lambda 算子&lt;/a&gt;」、&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/%25CE%259C-recursive_function&quot;&gt;μ-递归函数&lt;/a&gt;」等，它们在计算能力上都是与「图灵机」等价的。因此，我们可以用「图灵机」来证明「&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Computable_function&quot;&gt;可计算函数&lt;/a&gt;」的上界。也因此可以证明哪些计算问题是超出上界的（即不可解的）。&lt;/li&gt;
  &lt;li&gt;需要知道的是，只有「可计算的」才叫做「算法」。&lt;/li&gt;
  &lt;li&gt;「停机问题」响应了「哥德尔的不完备性定理」。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;拓展阅读&quot;&gt;拓展阅读：&lt;/h2&gt;

&lt;p&gt;中文：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.matrix67.com/blog/archives/55&quot;&gt;Matrix67: 不可解问题(Undecidable Decision Problem)&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.matrix67.com/blog/archives/901&quot;&gt;Matrix67: 停机问题、Chaitin 常数与万能证明方法&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//blog.csdn.net/pongba/article/details/1336028&quot;&gt;刘未鹏：康托尔、哥德尔、图灵–永恒的金色对角线(rev#2) - CSDN 博客&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.changhai.org/articles/science/mathematics/hilbert10/1.php&quot;&gt;卢昌海：Hilbert 第十问题漫谈 (上)&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;英文：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Introduction_to_the_Theory_of_Computation&quot;&gt;《Introduction to the Theory of Computation》&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DdNRDvLACg5Q&quot;&gt;Turing Machines Explained - Computerphile&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DmacM_MtS_w4%26t%3D29s&quot;&gt;Turing &amp;amp; The Halting Problem - Computerphile&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//cs.stackexchange.com/questions/32845/why-really-is-the-halting-problem-so-important&quot;&gt;Why, really, is the Halting Problem so important?&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 12 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/12/12/halting-problem/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/12/12/halting-problem/</guid>
        
        <category>知乎</category>
        
        <category>计算机科学</category>
        
        <category>计算理论</category>
        
        
      </item>
    
      <item>
        <title>「知乎」为什么 CSS 这么难学？</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;这篇文章转载自&lt;a href=&quot;https://www.zhihu.com/question/66167982/answer/240434582&quot;&gt;我在知乎上的回答&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对我来说，CSS 难学以及烦人是因为它&lt;strong&gt;「出乎我意料之外的复杂」&lt;/strong&gt;且让我觉得&lt;strong&gt;「定位矛盾」&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;//www.zhihu.com/people/b90c7eb6d3d5a4e2ce453dd8ad377672&quot;&gt;@方应杭&lt;/a&gt; 老师的答案我赞了：CSS 的属性互不正交，大量的依赖与耦合难以记忆。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;//www.zhihu.com/people/596c0a5fdd9b36cea06bac348d418824&quot;&gt;@顾轶灵&lt;/a&gt; &lt;a href=&quot;//www.zhihu.com/people/c02ec74a44ee4a6784d002c33e293652&quot;&gt;@王成&lt;/a&gt; 说得也没错：CSS 的很多规则是贯彻整个体系的，而且都记在规范里了，是有规律的，你应该好好读文档而不是去瞎试。&lt;/p&gt;

&lt;p&gt;「&lt;strong&gt;CSS是一门正儿八经的编程语言，请拿出你学C++或者Java的态度对待它&lt;/strong&gt;」&lt;/p&gt;

&lt;p&gt;但是问题就在这了，无论从我刚学习前端还是到现在，我都没有把 CSS 作为一门正儿八经的编程语言（&lt;strong&gt;而且显然图灵不完全的它也不是&lt;/strong&gt;），CSS 在我眼里一直就是一个布局、定义视觉样式用的 DSL，与 HTML 一样就是一个标记语言。&lt;/p&gt;

&lt;p&gt;写 CSS 很有趣，CSS 中像继承、类、伪类这样的设计确实非常迎合程序员的思路，各种排列组合带来了很多表达上的灵活性。但如果可以选择，在生产环境里我更愿意像 iOS/Android/Windows 开发那样，把这门 DSL 作为 IDE WYSIWYG 编辑器的编译目标就可以了，当然你可以直接编辑生成的代码，但我希望「对于同一种效果，有比较确定的 CSS 表达方式」&lt;/p&gt;

&lt;p&gt;因为我并不在 CSS 里处理数据结构，写算法、业务逻辑啊，我就是希望我能很精确得表达我想要的视觉效果就可以了。如果我需要更复杂的灵活性和控制，你可以用真正的编程语言来给我暴露 API，而不是在 CSS 里给我更多的「表达能力」&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CSS 语言本身的表达能力对于布局 DSL 来说是过剩的&lt;/strong&gt;，所以你仅仅用 CSS 的一个很小的子集就可以在 React Native 里搞定 iOS/Android 的布局了。你会发现各个社区（典型如 React）、团队都要花很多时间去找自己项目适合的那个 CSS 子集（so called 最佳实践）。而且 CSS 的这种复杂度其实还挺严重得影响了浏览器的渲染性能，很多优化变得很难做。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;而 CSS 的表达能力对于编程语言来说又严重不够&lt;/strong&gt;，一是语言特性不够，所以社区才会青睐 Less、Sass 这些编译到 CSS 的语言，然后 CSS 自己也在加不痛不痒的 Variable。二是 API 不够，就算你把规范读了，你会发现底层 CSSOM 的 Layout、Rendering 的东西你都只能强行用声明式的方式去 hack（比如用 transform 开新的 composition layer）而没有真正的 API 可以用，所以 W3C 才会去搞 Houdini 出来。&lt;/p&gt;

&lt;p&gt;这种不上不下的感觉就让我觉得很「矛盾」，你既没法把 CSS 当一个很简单的布局标记语言去使用，又没办法把它作为一个像样的编程语言去学习和使用。&lt;/p&gt;

&lt;p&gt;在写 CSS 和 debug CSS 的时候我经常处在一种「MD 就这样吧反正下次还要改」和「MD 这里凭什么是这样的我要研究下」的精分状态，可是明明我写 CSS 最有成就感的时候是看到漂亮的 UI 啊。&lt;/p&gt;

&lt;p&gt;以上。&lt;/p&gt;
</description>
        <pubDate>Fri, 06 Oct 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/10/06/css-complaints/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/10/06/css-complaints/</guid>
        
        <category>Web</category>
        
        <category>CSS</category>
        
        
      </item>
    
      <item>
        <title>Farewell, Flash. 感谢你，但这一次是真正的永别。</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;本文首发于我的知乎专栏 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/28109200&quot;&gt;The Little Programmer&lt;/a&gt;，转载请保留链接 ;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一年半前，我曾和 Flash 作过一次告别。那一次，Adobe Flash Professional CC 被重新命名为了 Adobe Animate CC，宣告着 Flash 作为一个创作工具走到了尽头。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-f-f-weibo.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而今天，通过 Chromium 博客 &lt;a href=&quot;https://blog.chromium.org/2017/07/so-long-and-thanks-for-all-flash.html&quot;&gt;So long, and thanks for all the Flash&lt;/a&gt; 我才得知，Adobe 官博在 &lt;a href=&quot;https://blogs.adobe.com/conversations/2017/07/adobe-flash-update.html&quot;&gt;Flash &amp;amp; The Future of Interactive Content&lt;/a&gt; 一文中，宣布将在 2020 年底时停止发布与更新 Flash Player。这一次，意味着 Flash 作为一个平台走到了尽头。&lt;/p&gt;

&lt;p&gt;在不少人眼里，Flash 与 HTML5 是纯粹的竞争关系，我们应该为 HTML5 与 Open Web 标准的胜利欢呼，而将 Flash 狠狠的咒骂在黄泉之下。但其实，大多数人都忘记了，或是从不曾知道：&lt;strong&gt;HTML5（严谨的来说，其 marketing 含义中所涵盖的那些 Web APIs），有很大一部分正是 Flash 平台、Flash 社区对 web 标准做出的贡献。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;正如 &lt;a href=&quot;https://blogs.adobe.com/conversations/2017/07/adobe-flash-update.html&quot;&gt;Flash &amp;amp; The Future of Interactive Content&lt;/a&gt; 所说：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Adobe has long played a leadership role in advancing interactivity and creative content – from video, to games and more – on the web. Where we’ve seen a need to push content and interactivity forward, we’ve innovated to meet those needs. &lt;strong&gt;Where a format didn’t exist, we invented one – such as with Flash and Shockwave. And over time, as the web evolved, these new formats were adopted by the community, in some cases formed the basis for open standards, and became an essential part of the web.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当我们（企业、用户）需要 web 平台承载包括视频、游戏在内的各种富交互内容而 web 平台本身还不具备这样的能力时，我们通过给予这个平台一种新的格式，以满足大家的需求，这就是 Flash Player，作为一种私有平台与浏览器插件，却能一度成为 web 事实标准的客观原因。&lt;/p&gt;

&lt;p&gt;而时至今日，这些 web 平台所欠缺的能力，在得到市场与社区的认可之后，逐渐被从 Flash 中吸收与扬弃，成为了诸如 HTML5 Video/Audio/Canvas、WebGL 这些真正的 Open Web 标准。这时候，这些在诞生之初颇为创新的，作为了一种「过渡手段」、「Shim」的私有平台，便自然而然的，慢慢的不再被需要了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这并不应该理解为一种失败，而应该说，它们「功成身退」了。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;ActionScript 3.0，Flash 中的御用编程语言，作为 ES4 的唯一实现，&lt;a href=&quot;https://www.zhihu.com/question/49170215/answer/114640341&quot;&gt;推动了 ECMAScript 标准的发展，深远得影响着现代 JavaScript&lt;/a&gt;；&lt;/p&gt;

&lt;p&gt;Adobe Flex，Flash 平台的企业开发框架，在今年和 &lt;a href=&quot;https://www.zhihu.com/people/sharpmaster&quot;&gt;@徐飞&lt;/a&gt; 老师聊到时，还一起怀念并认可其相比现代 web 前端/客户端开发在工具链、协作、兼容性、UI 组件等方面的先进与成熟；
Adobe AIR，作为最早借鉴 JRT 将 web 相关技术的 Runtime 植入操作系统或捆绑在可执行文件内的跨平台开发方案，或许可以视作 Cordova、Electron、NodeWebkit、ReactNative 这些方案的一个前身与成功先例；&lt;/p&gt;

&lt;p&gt;Microsoft IE 私有技术 ActiveX 中的 XMLHTTP，作为 XMLHTTPRequest 的前身，促进了 Ajax 的诞生与 Web 2.0 时代的来临；&lt;/p&gt;

&lt;p&gt;Google Gears 作为 2008 年时为了增强 web 应用的浏览器插件，其私有 API 分别是 App Cache、Web Worker、WebSQL 等标准或标准未遂的前身；&lt;/p&gt;

&lt;p&gt;Cordova/Phonegap 作为第一个面向移动端的 Hybrid 方案，成为了 web 开发与移动设备的 polyfill 与桥梁，加速了 Web 平台 Device APIs 的发展，并与 WebOS、FirefoxOS、Chrome Apps、Windows Runtime Apps 等一同影响了 Progressive Web App 的出现；&lt;/p&gt;

&lt;p&gt;Google Extension 中 Background Page 与 Event Page 多年对 web 平台后台持续计算的尝试，直接帮助了 Service Worker 的 API 设计；&lt;/p&gt;

&lt;p&gt;Google 的 NativeClient、Mozilla 的 asm.js 对于 web 追逐 native 性能的极致追求，则奠定了 Web Assembly 的诞生……&lt;/p&gt;

&lt;p&gt;你看，在这条道路上，Flash 与它的朋友们，其实并不孤单。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;「看到你长大了，我也就可以心满意足的离开了。」&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;就像是， web 技术发展的必然规律一样，&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;而 Open Web 则因此不朽。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;我很高兴，Google Chrome、Mozilla Firefox、Microsoft Edge 都能这么写到：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Flash helped make the web a rich, dynamic experience, and &lt;strong&gt;shaped the modern set of web standards.&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;— “&lt;a href=&quot;https://blog.chromium.org/2017/07/so-long-and-thanks-for-all-flash.html&quot;&gt;So long, and thanks for all the Flash&lt;/a&gt;” Chromium Blog&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Over the years, Flash has helped bring the Web to greatness with innovations in media and animation, &lt;strong&gt;which ultimately have been added to the core web platform.&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;— “&lt;a href=&quot;https://blog.mozilla.org/futurereleases/2017/07/25/firefox-roadmap-flash-end-life/&quot;&gt;Firefox Roadmap for Flash End-of-Life&lt;/a&gt;” Mozilla Blog&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Flash led the way on the web for rich content, gaming, animations, and media of all kinds, and &lt;strong&gt;inspired many of the current web standards powering HTML5.&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;— “&lt;a href=&quot;https://blogs.windows.com/msedgedev/2017/07/25/flash-on-windows-timeline/&quot;&gt;The End of an Era – Next Steps for Adobe Flash&lt;/a&gt;” Windows Blog&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;感谢你，Flash。&lt;/p&gt;

&lt;p&gt;感谢你们，那些「功成身退」的你们。&lt;/p&gt;
</description>
        <pubDate>Wed, 26 Jul 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/07/26/farewell-flash/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/07/26/farewell-flash/</guid>
        
        <category>Web</category>
        
        <category>Flash</category>
        
        
      </item>
    
      <item>
        <title>饿了么的 PWA 升级实践</title>
        <description>&lt;!-- Chinese Version --&gt;
&lt;div class=&quot;zh post-container&quot;&gt;
    
    
&lt;blockquote&gt;
  &lt;p&gt;很荣幸在今年 2 月到 5 月的时间里，以顾问的身份加入饿了么，参与 PWA 的相关工作。这篇文章其实最初是在以英文写作发表在 medium 上的：&lt;a href=&quot;https://medium.com/elemefe/upgrading-ele-me-to-progressive-web-app-2a446832e509&quot;&gt;Upgrading Ele.me to Progressive Web Apps&lt;/a&gt;，获得了一定的关注。所以也决定改写为中文版本再次分享出来，希望能对你有所帮助 ;) &lt;br /&gt;&lt;br /&gt;
本文首发于 &lt;a href=&quot;http://geek.csdn.net/news/detail/210535&quot;&gt;CSDN&lt;/a&gt; 与《程序员》2017 年 7 月刊，同步发布于 &lt;a href=&quot;https://zhuanlan.zhihu.com/ElemeFE&quot;&gt;饿了么前端 - 知乎专栏&lt;/a&gt;、&lt;a href=&quot;https://huangxuan.me&quot;&gt;Hux Blog&lt;/a&gt;，转载请保留链接。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;自 Vue.js 官方推特第一次&lt;a href=&quot;https://twitter.com/vuejs/status/834087199008239619&quot;&gt;公开&lt;/a&gt;到现在，我们就一直在进行着将&lt;a href=&quot;https://h5.ele.me/msite/#pwa=true&quot;&gt;饿了么移动端网站&lt;/a&gt;升级为 &lt;a href=&quot;https://developers.google.com/web/progressive-web-apps/&quot;&gt;Progressive Web App&lt;/a&gt; 的工作。直到近日在 Google I/O 2017 上&lt;a href=&quot;https://m.weibo.cn/status/4109332495285652&quot;&gt;登台亮相&lt;/a&gt;，才终于算告一段落。我们非常荣幸能够发布全世界第一个专门面向国内用户的 PWA，但更荣幸的是能与 Google、UC 以及腾讯合作，一起推动国内 web 与浏览器生态的发展。&lt;/p&gt;

&lt;h2 id=&quot;多页应用vuepwa&quot;&gt;多页应用、Vue、PWA？&lt;/h2&gt;

&lt;p&gt;对于构建一个希望达到原生应用级别体验的 PWA，目前社区里的主流做法都是采用 SPA，即单页面应用模型（Single-page App）来组织整个 web 应用，业内最有名的几个 PWA 案例 &lt;a href=&quot;https://blog.twitter.com/2017/how-we-built-twitter-lite&quot;&gt;Twitter Lite&lt;/a&gt;、 &lt;a href=&quot;https://medium.com/progressive-web-apps/building-flipkart-lite-a-progressive-web-app-2c211e641883&quot;&gt;Flipkart Lite&lt;/a&gt;、&lt;a href=&quot;https://medium.com/engineering-housing/progressing-mobile-web-fac3efb8b454&quot;&gt;Housing Go&lt;/a&gt; 与 &lt;a href=&quot;https://shop.polymer-project.org/&quot;&gt;Polymer Shop&lt;/a&gt; 无一例外。&lt;/p&gt;

&lt;p&gt;然而饿了么，与很多国内的电商网站一样，青睐多页面应用模型（MPA，Multi-page App）所能带来的一些好处，也因此在一年多将移动站从基于 Angular.js 的单页应用重构为目前的多页应用模型。团队最看重的优点莫过于页面与页面之间的隔离与解耦，这使得我们可以将每个页面当做一个独立的“微服务”来看待，这些服务可以被独立迭代，独立提供给各种第三方的入口嵌入，甚至被不同的团队独立维护。而整个网站则只是各种服务的集合而非一个巨大的整体。&lt;/p&gt;

&lt;p&gt;与此同时，我们仍然依赖 &lt;a href=&quot;http://vuejs.org/&quot;&gt;Vue.js&lt;/a&gt; 作为 JavaScript 框架。Vue 除了是 React/Angular 这种“重型武器”的竞争对手外，其轻量与高性能的优点使得它同样可以作为传统多页应用开发中流行的 “jQuery/Zepto/Kissy + 模板引擎” 技术栈的完美替代。Vue 提供的组件系统、声明式与响应式编程更是提升了代码组织、共享、数据流控制、渲染等各个环节的开发效率。&lt;a href=&quot;(https://www.youtube.com/watch?v=pBBSp_iIiVM)&quot;&gt;Vue 还是一个渐进式框架&lt;/a&gt;，如果网站的复杂度继续提升，我们可以按需、增量地引入 Vuex 或 Vue-Router 这些模块。万一哪天又要改回单页呢？（谁知道呢……）&lt;/p&gt;

&lt;p&gt;2017 年，PWA 已经成为 web 应用新的风潮。我们决定试试，以我们现有的“Vue + 多页”的架构，能在升级 PWA 的道路上走多远，达到怎样的效果。&lt;/p&gt;

&lt;h2 id=&quot;实现-prpl-模式&quot;&gt;实现 “PRPL” 模式&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/prpl-pattern/&quot;&gt;“PRPL”&lt;/a&gt;（读作 “purple”）是 Google 的工程师提出的一种 web 应用架构模式，它旨在利用现代 web 平台的新技术以大幅优化移动 web 的性能与体验，对如何组织与设计高性能的 PWA 系统提供了一种高层次的抽象。我们并不准备从头重构我们的 web 应用，不过我们可以把实现 “PRPL” 模式作为我们的迁移目标。“PRPL”实际上是 Push/Preload、Render、Precache、Lazy-Load 的缩写，我们会在下文中展开它们的具体含义。&lt;/p&gt;

&lt;h3 id=&quot;1-pushpreload推送预加载初始-url-路由所需的关键资源&quot;&gt;1. PUSH/PRELOAD，推送/预加载初始 URL 路由所需的关键资源。&lt;/h3&gt;

&lt;p&gt;无论是 HTTP2 Server Push 还是 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;link rel=&quot;preload&quot;&amp;gt;&lt;/code&gt;，其关键都在于，我们希望提前请求一些隐藏在应用依赖关系（Dependency Graph）较深处的资源，以节省 HTTP 往返、浏览器解析文档、或脚本执行的时间。比如说，对于一个基于路由进行 code splitting 的 SPA，如果我们可以在 webpack 清单、路由等入口代码（entry chunks）被下载与运行之前就把初始 URL，即用户访问的入口 URL 路由所依赖的代码用 Server Push 推送或 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;link rel=&quot;preload&quot;&amp;gt;&lt;/code&gt; 进行提前加载。那么当这些资源被真正请求时，它们可能已经下载好并存在在缓存中了，这样就加快了初始路由所有依赖的就绪。&lt;/p&gt;

&lt;p&gt;在多页应用中，每一个路由本来就只会请求这个路由所需要的资源，并且通常依赖也都比较扁平。饿了么移动站的大部分脚本依赖都是普通的 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 元素，因此他们可以在文档解析早期就被浏览器的 preloader 扫描出来并且开始请求，其效果其实与显式的 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;link rel=&quot;preload&quot;&amp;gt;&lt;/code&gt; 是一致的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-eleme-pwa/PUSH-link-rel-preload.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们还将所有关键的静态资源都伺服在同一域名下（不再做域名散列），以更好的利用 HTTP2 带来的多路复用（Multiplexing）。同时，我们也在进行着对 API 进行 Server Push 的&lt;a href=&quot;https://zhuanlan.zhihu.com/p/26757514&quot;&gt;实验&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;2-render渲染初始路由尽快让应用可被交互&quot;&gt;2. RENDER，渲染初始路由，尽快让应用可被交互&lt;/h3&gt;

&lt;p&gt;既然所有初始路由的依赖都已经就绪，我们就可以尽快开始初始路由的渲染，这有助于提升应用诸如首次渲染时间、可交互时间等指标。多页应用并不使用基于 JavaScript 的路由，而是传统的 HTML 跳转机制，所以对于这一部分，多页应用其实不用额外做什么。&lt;/p&gt;

&lt;h3 id=&quot;3-pre-cache用-service-worker-预缓存剩下的路由&quot;&gt;3. PRE-CACHE，用 Service Worker 预缓存剩下的路由&lt;/h3&gt;

&lt;p&gt;这一部分就需要 &lt;a href=&quot;https://w3c.github.io/ServiceWorker/v1/&quot;&gt;Service Worker&lt;/a&gt; 的参与了，Service Worker 是一个位于浏览器与网络之间的客户端代理，它以可拦截、处理、响应流经的 HTTP 请求，使得开发者得以从缓存中向 web 应用提供资源而闻名。不过，Service Worker 其实也可以主动发起 HTTP 请求，在“后台” 预请求与预缓存我们未来所需要的资源。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-eleme-pwa/PRECACHE-future-routes.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们已经使用 &lt;a href=&quot;https://webpack.github.io/&quot;&gt;Webpack&lt;/a&gt; 在构建过程中进行 &lt;code class=&quot;highlighter-rouge&quot;&gt;.vue&lt;/code&gt; 编译、文件名哈希等工作，于是我们编写了一个 webpack 插件来帮助我们收集需要缓存的依赖到一个“预缓存清单”中，并使用这个清单在每次构建时生成新的 Service Worker 文件。在新的 Service Worker 被激活时，清单里的资源就会被请求与缓存，这其实与 &lt;a href=&quot;https://medium.com/@Huxpro/how-does-sw-precache-works-2d99c3d3c725&quot;&gt;SW-Precache 这个库的运行机制&lt;/a&gt;非常接近。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实际上，我们只对我们标记为“关键路由”的路由进行依赖收集。&lt;/strong&gt;你可以将这些“关键路由”的依赖理解为我们整个应用的 &lt;a href=&quot;https://developers.google.com/web/updates/2015/11/app-shell&quot;&gt;“App Shell”&lt;/a&gt; 或者说“安装包”。一旦它们都被缓存，或者说成功安装，无论用户是在线离线，我们的 web 应用都可以从缓存中直接启动。对于那些并不那么重要的路由，我们则采取在运行时增量缓存的方式。我们使用的 &lt;a href=&quot;https://googlechrome.github.io/sw-toolbox/&quot;&gt;SW-Toolbox&lt;/a&gt; 提供了 LRU 替换策略与 TTL 失效机制，可以保证我们的应用不会超过浏览器的缓存配额。&lt;/p&gt;

&lt;h3 id=&quot;4-lazy-load-按需懒加载懒实例化剩下的路由&quot;&gt;4. LAZY-LOAD 按需懒加载、懒实例化剩下的路由&lt;/h3&gt;

&lt;p&gt;懒加载与懒实例化剩下的路由对于 SPA 是一件相对麻烦点儿的事情，你需要实现基于路由的 code splitting 与异步加载。幸运的是，这又是一件不需要多页应用担心的事情，多页应用中的各个路由天生就是分离的。&lt;/p&gt;

&lt;p&gt;值得说明的是，无论单页还是多页应用，如果在上一步中，我们已经将这些路由的资源都预先下载与缓存好了，那么懒加载就几乎是瞬时完成的了，这时候我们就只需要付出实例化的代价。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;这四句话即是 PRPL 的全部了。有趣的是，我们发现多页应用在实现 PRPL 这件事甚至比单页还要容易一些。那么结果如何呢？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-eleme-pwa/Lighthouse-before.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;根据 Google 推出的 Web 性能分析工具 Lighthouse（v1.6），在模拟的 3G 网络下，用户的初次访问（无任何缓存）大约在 2 秒左右达到“可交互”，可以说非常不错。而对于再次访问，由于所有资源都直接来自于 Service Worker 缓存，页面可以在 1 秒左右就达到可交互的状态了。&lt;/p&gt;

&lt;p&gt;但是，故事并不是这么简单得就结束了。在实际的体验中我们发现，&lt;strong&gt;应用在页与页的切换时，仍然存在着非常明显的白屏空隙&lt;/strong&gt;，由于 PWA 是全屏运行的，白屏对用户体验所带来的负面影响甚至比以往在浏览器内更大。我们不是已经用 Service Worker 缓存了所有资源了吗，怎么还会这样呢？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-eleme-pwa/before-skeleton.jpg&quot; alt=&quot;&quot; /&gt;
&lt;em&gt;从首页点击到发现页，跳转过程中的白屏&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;多页应用的陷阱重启开销&quot;&gt;多页应用的陷阱：重启开销&lt;/h2&gt;

&lt;p&gt;与 SPA 不同，在多页应用中，路由的切换是原生的浏览器文档跳转（Navigating across documents），这意味着之前的页面会被完全丢弃而浏览器需要为下一个路由的页面重新执行所有的启动步骤：重新下载资源、重新解析 HTML、重新运行 JavaScript、重新解码图片、重新布局页面、重新绘制……即使其中的很多步骤本是可以在多个路由之间复用的。这些工作无疑将产生巨大的计算开销，也因此需要付出相当的时间成本。&lt;/p&gt;

&lt;p&gt;图中为我们的入口页（同时也是最重的页面）在 2 倍 CPU 节流模拟下的 profile 数据。即使我们可以将“可交互时间”控制在 1 秒左右，我们的用户仍然会觉得这对于“仅仅切换个标签”来说实在是太慢了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-eleme-pwa/msite-Before-Optim.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;巨大的-javascript-重启开销&quot;&gt;巨大的 JavaScript 重启开销&lt;/h3&gt;

&lt;p&gt;根据 Profile，我们发现在首次渲染（First Paint）发生之前，大量的时间（900 毫秒）都消耗在了 JavaScript 的运行上（Evaluate Script）。几乎所有脚本都是阻塞的（Parser-blocking），不过因为所有的 UI 都是由 JavaScript/Vue 驱动的，倒也不会有性能影响。这 900ms 中，约一半是消耗在包括 Vue 运行时、组件、库等依赖的运行上，而另一半则花在了业务组件实例化时 Vue 的启动与渲染上。从软件工程角度来说，我们需要这些抽象，所以这里并不是想责怪 JavaScript 或是 Vue 所带来的开销。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;但是，在 SPA 中，JavaScript 的启动成本是均摊到整个生命周期的：&lt;/strong&gt; 每个脚本都只需要被解析与编译一次，诸如生成 Virtual DOM 等较重的任务可以只执行一次，像 Vue 的 ViewModel 或是 Virtual DOM 这样的大对象也可以被留在内存里复用。&lt;strong&gt;可惜在多页应用里就不是这样了，我们每次切换页面都为 JavaScript 付出了巨大的重启代价。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;浏览器的缓存啊能不能帮帮忙&quot;&gt;浏览器的缓存啊，能不能帮帮忙？&lt;/h3&gt;

&lt;p&gt;能，也不能。&lt;/p&gt;

&lt;p&gt;V8 提供了&lt;a href=&quot;http://v8project.blogspot.com/2015/07/code-caching.html&quot;&gt;代码缓存（code caching）&lt;/a&gt;，可以将编译后的机器码在本地拷贝一份，这样我们就可以在下次请求同一个脚本时一次省略掉请求、解析、编译的所有工作。而且，对于缓存在 Service Worker 配套的 Cache Storage 中的脚本，会在第一次执行后就触发 V8 的代码缓存，这对于我们的多页切换能提供不少帮助。&lt;/p&gt;

&lt;p&gt;另外一个你或许听过的浏览器缓存叫做“进退缓存”，Back-Forward Cache，简称 bfcache。浏览器厂商对其的命名各异，Opera 称之为 Fast History Navigation，Webkit 称其为 Page Cache。但是思路都一样，&lt;strong&gt;就是我们可以让浏览器在跳转时把前一页留存在内存中，保留 JavaScript 与 DOM 的状态，而不是全都销毁掉。&lt;/strong&gt;你可以随便找个传统的多页网站在 iOS Safari 上试试，无论是通过浏览器的前进后退按钮、手势，还是通过超链接（会有一些不同），基本都可以看到瞬间加载的效果。&lt;/p&gt;

&lt;p&gt;Bfcache 其实非常适合多页应用。但不幸的是，Chrome 由于内存开销与其多进程架构等原因目前并不支持。Chrome 现阶段仅仅只是用了传统的 HTTP 磁盘缓存，来稍稍简化了一下加载过程而已。对于 Chromium 内核霸占的 Android 生态来说，我们没法指望了。&lt;/p&gt;

&lt;h2 id=&quot;为感知体验奋斗&quot;&gt;为“感知体验”奋斗&lt;/h2&gt;

&lt;p&gt;尽管多页应用面临着现实中的不少性能问题，我们并不想这么快就妥协。一方面，我们尝试尽可能减少在页面达到可交互时间前的代码执行量，比如减少/推迟一些依赖脚本的执行，还有减少初次渲染的 DOM 节点数以节省 Virtual DOM 的初始化开销。另一方面，我们也意识到应用在感知体验上还有更多的优化空间。&lt;/p&gt;

&lt;p&gt;Chrome 产品经理 Owen 写过一篇 &lt;a href=&quot;https://medium.com/@owencm/reactive-web-design-the-secret-to-building-web-apps-that-feel-amazing-b5cbfe9b7c50&quot;&gt;Reactive Web Design: The secret to building web apps that feel amazing&lt;/a&gt;，谈到两种改进感知体验的手段：一是使用骨架屏（Skeleton Screen）来实现瞬间加载；二是预先定义好元素的尺寸来保证加载的稳定。跟我们的做法可以说不谋而合。&lt;/p&gt;

&lt;p&gt;为了消除白屏时间，我们同样引入了尺寸稳定的骨架屏来帮助我们实现瞬间的加载与占位。即使是在硬件很弱的设备上，我们也可以在点击切换标签后立刻渲染出目标路由的骨架屏，以保证 UI 是稳定、连续、有响应的。我录了&lt;a href=&quot;https://youtu.be/K5JBGnMYO1s&quot;&gt;两个&lt;/a&gt;&lt;a href=&quot;https://youtu.be/w1ZbNsHmRjs&quot;&gt;视频&lt;/a&gt;放在 Youtube 上，不过如果你是国内读者，你可以直接访问饿了么移动网站来体验实地的效果 ;) 最终效果如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-eleme-pwa/after-skeleton.jpg&quot; alt=&quot;&quot; /&gt;
&lt;em&gt;在添加骨架屏后，从发现页点回首页的效果&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;这效果本该很轻松的就能实现，不过实际上我们还费了点功夫。&lt;/p&gt;

&lt;h3 id=&quot;在构建时使用-vue-预渲染骨架屏&quot;&gt;在构建时使用 Vue 预渲染骨架屏&lt;/h3&gt;

&lt;p&gt;你可能已经想到了，为了让骨架屏可以被 Service Worker 缓存，瞬间加载并独立于 JavaScript 渲染，我们需要把组成骨架屏的 HTML 标签、CSS 样式与图片资源一并内联至各个路由的静态 &lt;code class=&quot;highlighter-rouge&quot;&gt;*.html&lt;/code&gt; 文件中。&lt;/p&gt;

&lt;p&gt;不过，我们并不准备手动编写这些骨架屏。你想啊，如果每次真实组件有迭代（每一个路由对我们来说都是一个 Vue 组件）我们都需要手动去同步每一个变化到骨架屏的话，那实在是太繁琐且难以维护了。好在，&lt;a href=&quot;https://www.lukew.com/ff/entry.asp?1797&quot;&gt;骨架屏不过是当数据还未加载进来前，页面的一个空白版本而已&lt;/a&gt;。如果我们能将骨架屏实现为真实组件的一个特殊状态 —— “空状态”的话，我们理论上就可以从真实组件中直接渲染出骨架屏来。&lt;/p&gt;

&lt;p&gt;而 Vue 的多才多艺就在这时体现出来了，我们真的可以用 &lt;a href=&quot;https://ssr.vuejs.org/en/&quot;&gt;Vue.js 的服务端渲染模块&lt;/a&gt; 来实现这个想法，不过不是用在真正的服务器上，而是在构建时用它把组件的空状态预先渲染成字符串并注入到 HTML 模板中。你需要调整你的 Vue 组件代码使得它可以在 Node 上执行，有些页面对 DOM/BOM 的依赖一时无法轻易去除得，我们目前只好额外编写一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;*.shell.vue&lt;/code&gt; 来暂时绕过这个问题。&lt;/p&gt;

&lt;h3 id=&quot;关于浏览器的绘制painting&quot;&gt;关于浏览器的绘制（Painting）&lt;/h3&gt;

&lt;p&gt;HTML 文件中有标签并不意味着这些标签就能立刻被绘制到屏幕上，你必须保证页面的&lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/critical-rendering-path/&quot;&gt;关键渲染路径&lt;/a&gt;是为此优化的。很多开发者相信将 script 标签放在 body 的底部就足以保证内容能在脚本执行之前被绘制，这对于能渲染不完整 DOM 树的浏览器（比如桌面浏览器常见的流式渲染）来说可能是成立的。但移动端的浏览器很可能因为考虑到较慢的硬件、电量消耗等因素并不这么做。&lt;strong&gt;不仅如此，即使你曾被告知设为 &lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;defer&lt;/code&gt; 的脚本就不会阻塞 HTML 解析了，但这可不意味着浏览器就一定会在执行它们之前进行渲染。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://html.spec.whatwg.org/images/asyncdefer.svg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先我想澄清的是，根据 &lt;a href=&quot;https://html.spec.whatwg.org/multipage/scripting.html&quot;&gt;HTML 规范 Scripting 章节&lt;/a&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt; 脚本是在其请求完成后立刻运行的，因此它本来就可能阻塞到解析。只有 &lt;code class=&quot;highlighter-rouge&quot;&gt;defer&lt;/code&gt;（且非内联）与最新的 &lt;code class=&quot;highlighter-rouge&quot;&gt;type=module&lt;/code&gt; 被指定为“一定不会阻塞解析”。（不过 &lt;code class=&quot;highlighter-rouge&quot;&gt;defer&lt;/code&gt; 目前也有点小问题……我们稍后会再提到）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;而更重要的是，一个不阻塞 HTML 解析的脚本仍然可能阻塞到绘制。&lt;/strong&gt;我做了一个简化的&lt;strong&gt;“最小多页 PWA”&lt;/strong&gt;（Minimal Multi-page PWA，或 MMPWA）来测试这个问题，：我们在一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt;（且确实不阻塞 HTML 解析）脚本中，生成并渲染 1000 个列表项，然后测试骨架屏能否在脚本执行之前渲染出来。下面是通过 USB Debugging 在我的 Nexus 5 真机上录制的 profile：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-eleme-pwa/thisTick-&amp;amp;-Load.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;是的，出乎意料吗？首次渲染确实被阻塞到脚本执行结束后才发生。究其原因，&lt;strong&gt;如果我们在浏览器还未完成上一次绘制工作之前就过快得进行了 DOM 操作，我们亲爱的浏览器就只好抛弃所有它已经完成的像素，且一直要等待到 DOM 操作引起的所有工作结束之后才能重新进行下一次渲染。&lt;/strong&gt;而这种情况更容易在拥有较慢 CPU/GPU 的移动设备上出现。&lt;/p&gt;

&lt;h3 id=&quot;黑魔法利用-settimeout-让绘制提前&quot;&gt;黑魔法：利用 setTimeout() 让绘制提前&lt;/h3&gt;

&lt;p&gt;不难发现，骨架屏的绘制与脚本执行实际是一个竞态。大概是 Vue 太快了，我们的骨架屏还是有非常大的概率绘制不出来。于是我们想着如何能让脚本执行慢点，或者说，“懒”点。于是我们想到了一个经典的 Hack： &lt;code class=&quot;highlighter-rouge&quot;&gt;setTimeout(callback, 0)&lt;/code&gt;。我们试着把 MMPWA 中的 DOM 操作（渲染 1000 个列表）放进 &lt;code class=&quot;highlighter-rouge&quot;&gt;setTimeout(callback, 0)&lt;/code&gt; 里……&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-eleme-pwa/nextTick-&amp;amp;-Load.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当当！首次渲染瞬间就被提前了。如果你熟悉浏览器的&lt;strong&gt;事件循环模型（event loop）&lt;/strong&gt;的话，这招 Hack 其实是通过 setTimeout 的回调把 DOM 操作放到了事件循环的任务队列中以避免它在当前循环执行，这样浏览器就得以在主线程空闲时喘息一下（更新一下渲染）了。如果你想亲手试试 MMPWA 的话，你可以访问 &lt;a href=&quot;https://github.com/Huxpro/mmpwa&quot;&gt;github.com/Huxpro/mmpwa&lt;/a&gt; 或 &lt;a href=&quot;https://huangxuan.me/mmpwa&quot;&gt;huangxuan.me/mmpwa/&lt;/a&gt; 访问代码与 Demo。我把 UI 设计为了 A/B Test 的形式并改为渲染 5000 个列表项来让效果更夸张一些。&lt;/p&gt;

&lt;p&gt;回到饿了么 PWA 上，我们同样试着把 &lt;code class=&quot;highlighter-rouge&quot;&gt;new Vue()&lt;/code&gt; 放到了 &lt;code class=&quot;highlighter-rouge&quot;&gt;setTimeout&lt;/code&gt; 中。果然，黑魔法再次显灵，骨架屏在每次跳转后都能立刻被渲染。这时的 Profile 看起来是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-eleme-pwa/msite-After-Optim.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在，我们在 400ms 时触发首次渲染（骨架屏），在 600ms 时完成真实 UI 的渲染并达到页面的可交互。你可以拉上去详细对比下优化前后 profile 的区别。&lt;/p&gt;

&lt;h3 id=&quot;被我-defer-的有关-defer-的-bug&quot;&gt;被我 “defer” 的有关 &lt;code class=&quot;highlighter-rouge&quot;&gt;defer&lt;/code&gt; 的 Bug&lt;/h3&gt;

&lt;p&gt;不知道你发现没有，在上图的 Profile 中，我们仍然有不少脚本是阻塞了 HTML 解析的。好吧让我解释一下，由于历史原因，我们确实保留了一部分的阻塞脚本，比如侵入性很强的 &lt;a href=&quot;https://github.com/amfe/lib-flexible&quot;&gt;lib-flexible&lt;/a&gt;，我们没法轻易去除它。不过，profile 里的大部分阻塞脚本实际上都设置了 &lt;code class=&quot;highlighter-rouge&quot;&gt;defer&lt;/code&gt;，我们本以为他们应该在 HTML 解析完成之后才被执行，结果被 profile 打了一脸。&lt;/p&gt;

&lt;p&gt;我和 &lt;a href=&quot;https://twitter.com/jaffathecake&quot;&gt;Jake Archibald&lt;/a&gt; &lt;a href=&quot;https://twitter.com/Huxpro/status/859842124849827841&quot;&gt;聊了一下&lt;/a&gt;，果然这是 Chrome 的 Bug：&lt;code class=&quot;highlighter-rouge&quot;&gt;defer&lt;/code&gt; 的脚本被完全缓存时，并没有遵守规范等待解析结束，反而阻塞了解析与渲染。Jake 已经提交在 &lt;a href=&quot;https://bugs.chromium.org/p/chromium/issues/detail?id=717979&quot;&gt;crbug&lt;/a&gt; 上了，一起给它投票吧~&lt;/p&gt;

&lt;p&gt;最后，是优化后的 Lighthouse 跑分结果，同样可以看到明显的性能提升。需要说明的是，能影响 Lighthouse 跑分的因素有很多，所以我建议你以控制变量（跑分用的设备、跑分时的网络环境等）的方式来进行对照实验。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-eleme-pwa/Lighthouse-after.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后附上一张图，这张图当时是做给 Addy Osmani 的 I/O 演讲用的，描述了饿了么 PWA 是如何结合 Vue 来实现多页应用的 PRPL 模式，可以作为一个架构的参考与示意图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-eleme-pwa/Architecture.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;一些感想&quot;&gt;一些感想&lt;/h2&gt;

&lt;h3 id=&quot;多页应用仍然有很长的路要走&quot;&gt;多页应用仍然有很长的路要走&lt;/h3&gt;

&lt;p&gt;Web 是一个极其多样化的平台。从静态的博客，到电商网站，再到桌面级的生产力软件，它们全都是 Web 这个大家庭的第一公民。而我们组织 web 应用的方式，也同样只会更多而不会更少：多页、单页、Universal JavaScript 应用、WebGL、以及可以预见的 Web Assembly。不同的技术之间没有贵贱，但是适用场景的差距确是客观存在的。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://twitter.com/jaffathecake&quot;&gt;Jake&lt;/a&gt; 曾在 &lt;a href=&quot;https://youtu.be/J2dOTKBoTL4?list=PLNYkxOF6rcIBTs2KPy1E6tIYaWoFcG3uj&quot;&gt;Chrome Dev Summit 2016&lt;/a&gt; 上说过 “PWA !== SPA”。可是尽管我们已经用上了一系列最新的技术（PRPL、Service Worker、App Shell……），我们仍然因为多页应用模型本身的缺陷有着难以逾越的一些障碍。多页应用在未来可能会有“bfcache API”、Navigation Transition 等新的规范以缩小跟 SPA 的距离，不过我们也必须承认，时至今日，多页应用的局限性也是非常明显的。&lt;/p&gt;

&lt;h3 id=&quot;而-pwa-终将带领-web-应用进入新的时代&quot;&gt;而 PWA 终将带领 web 应用进入新的时代&lt;/h3&gt;

&lt;p&gt;即使我们的多页应用在升级 PWA 的路上不如单页的那些来得那么闪亮，但是 PWA 背后的想法与技术却实实在在的帮助我们在 web 平台上提供了更好的用户体验。&lt;/p&gt;

&lt;p&gt;PWA 作为&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25167289&quot;&gt;下一代 Web 应用模型&lt;/a&gt;，其尝试解决的是 web 平台本身的根本性问题：对网络与浏览器 UI 的硬依赖。因此，任何 web 应用都可以从中获益，这与你是多页还是单页、面向桌面还是移动端、是用 React 还是 Vue 无关。或许，它还终将改变用户对移动 web 的期待。现如今，谁还觉得桌面端的 web 只是个看文档的地方呢？&lt;/p&gt;

&lt;p&gt;还是那句老话：让我们的用户，也像我们这般热爱 web 吧。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;最后，感谢饿了么的王亦斯、任光辉、题叶，Google 的 Michael Yeung、DevRel 团队， UC 浏览器团队，腾讯 X5 浏览器团队在这次项目中的合作。感谢尤雨溪、陈蒙迪和 Jake Archibald 在写作过程中给予我的帮助。&lt;/p&gt;


&lt;/div&gt;

&lt;!-- English Version --&gt;
&lt;div class=&quot;en post-container&quot;&gt;
    
    &lt;blockquote&gt;
  &lt;p&gt;Read at medium.com: &lt;a href=&quot;https://medium.com/elemefe/upgrading-ele-me-to-progressive-web-app-2a446832e509&quot;&gt;Upgrading Ele.me to Progressive Web Apps&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Since the very first experiments that &lt;a href=&quot;https://twitter.com/vuejs/status/834087199008239619&quot;&gt;@Vue.js tweeted&lt;/a&gt;, we at Ele.me (the biggest food ordering and delivering company in China) have been working on upgrading our mobile website to a &lt;a href=&quot;https://developers.google.com/web/progressive-web-apps/&quot;&gt;Progressive Web App&lt;/a&gt;. We’re proud to ship the world-first PWA exclusively for the Chinese market, but even prouder to collaborate with Google, UC and Tencent to push the boundary of web experience and browser supports in China.&lt;/p&gt;

&lt;h2 id=&quot;multi-page-vue-pwa&quot;&gt;Multi-page, Vue, PWA?&lt;/h2&gt;

&lt;p&gt;There is a prevailing opinion that only structuring a web app as a Single Page App can we build PWAs that deliver app-like user experience. Popular reference examples including &lt;a href=&quot;https://blog.twitter.com/2017/how-we-built-twitter-lite&quot;&gt;Twitter Lite&lt;/a&gt;, &lt;a href=&quot;https://medium.com/progressive-web-apps/building-flipkart-lite-a-progressive-web-app-2c211e641883&quot;&gt;Flipkart Lite&lt;/a&gt;, &lt;a href=&quot;https://medium.com/engineering-housing/progressing-mobile-web-fac3efb8b454&quot;&gt;Housing Go&lt;/a&gt; and &lt;a href=&quot;https://shop.polymer-project.org/&quot;&gt;Polymer Shop&lt;/a&gt; are all using the SPA model.&lt;/p&gt;

&lt;p&gt;However at Ele.me, we’ve come to appreciate many advantages of a Multi-Page App model, and decided to refactor the mobile site from an Angular 1 SPA to a Multi-Paged app more than a year ago. The most important advantage we see is the isolation and decoupling between pages, which allows us to built different parts of the mobile site as “micro-services”. These services can then be independently iterated, embedded into 3rd-party apps, and even maintained by different teams.&lt;/p&gt;

&lt;p&gt;Meanwhile, we still leverage &lt;a href=&quot;http://vuejs.org/&quot;&gt;Vue.js&lt;/a&gt; to boost our productivity. You may have heard of Vue as a rival of React or Angular, but Vue’s lightweight and performance make it also a perfect replacement of traditional “jQuery/Zepto + template engine” stack when engineering a Multi-page app. We built every component as &lt;a href=&quot;http://vuejs.org/v2/guide/single-file-components.html&quot;&gt;Single File Components&lt;/a&gt; so they can be easily shareable between pages. The declarative-ness plus reactivity Vue offered help us manage both code and data flow. Oh, did I mention that &lt;a href=&quot;https://www.youtube.com/watch?v=pBBSp_iIiVM&quot;&gt;Vue is progressive&lt;/a&gt;? So things like Vuex or Vue-Router can be incrementally adopted if our site’s complexity scales up, like…migrating to SPA again? (Who knows…)&lt;/p&gt;

&lt;p&gt;In 2017, PWA seems to be all the rage, so we embark on exploring how far can our Vue-based Multi-page PWAs actually go.&lt;/p&gt;

&lt;h2 id=&quot;implementing-prpl-with-mpa&quot;&gt;Implementing “PRPL” with MPA&lt;/h2&gt;

&lt;p&gt;I love &lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/prpl-pattern/&quot;&gt;PRPL pattern&lt;/a&gt; because it gives you a high-level abstraction of how to structure and design your own PWA systems. Since we are not rebuild everything from scratch, we decided taking implementing PRPL as our migration goal:&lt;/p&gt;

&lt;h3 id=&quot;1-push-critical-resources-for-initial-url-route&quot;&gt;1. PUSH critical resources for initial URL route.&lt;/h3&gt;

&lt;p&gt;The key of pushing/preloading is to prioritize resources hidden in deep dependency graph and make browser’s network stack busy ASAP. Let’s say you have a SPA with code splitting by route, you can push/preload chunks for the current route before the “entry chunks” (e.g. webpack manifest, router) finish downloading and evaluating. So when the actual fetches happen, they might already be in caches.&lt;/p&gt;

&lt;p&gt;Routes in MPAs naturally fetch code for that route only, and tend to have a flattening dependency graph. Most scripts depended by Ele.me are just &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;script&amp;gt;&lt;/code&gt; elements, so they can be found and fetched by &lt;a href=&quot;https://calendar.perfplanet.com/2013/big-bad-preloader/&quot;&gt;good old browser preloader&lt;/a&gt; in early parsing phase without explicit &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;link rel=&quot;preload&quot;&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-eleme-pwa/PUSH-link-rel-preload.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To take benefits from HTTP2 Multiplexing, we currently serve all critical resources under a single domain (no more domain sharding), and we are also experimenting on Server Push.&lt;/p&gt;

&lt;h3 id=&quot;2-render-initial-route--get-it-interactive-asap&quot;&gt;2. RENDER initial route &amp;amp; get it interactive ASAP&lt;/h3&gt;

&lt;p&gt;This one is essentially free (ridiculously obvious) in MPA since there’s only one route at one time.&lt;/p&gt;

&lt;p&gt;A straightforward rendering is critical for metrics such as First-Meaningful-Paint and Time-To-Interactive. MPAs gain it for free due to the simplicity of traditional HTML navigation they used.&lt;/p&gt;

&lt;h3 id=&quot;3-pre-cache-remaining-routes-using-service-worker&quot;&gt;3. &lt;strong&gt;PRE-CACHE&lt;/strong&gt; remaining routes using Service Worker&lt;/h3&gt;

&lt;p&gt;This’s the part &lt;a href=&quot;https://w3c.github.io/ServiceWorker/v1/&quot;&gt;Service Worker&lt;/a&gt; come to join the show. Service Worker is known as a client-side proxy enabling developers to intercept requests and serve responses from cache, but it can also perform initiative fetch to prefetch then precache future resources.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-eleme-pwa/PRECACHE-future-routes.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We already used &lt;a href=&quot;https://webpack.github.io/&quot;&gt;Webpack&lt;/a&gt; in the build process to do &lt;code class=&quot;highlighter-rouge&quot;&gt;.vue&lt;/code&gt; compilation and asset versioning, so we create a webpack plugin to help us collecting dependencies into a “precache manifest” and generating a new Service Worker file after each build. This is pretty much like &lt;a href=&quot;https://medium.com/@Huxpro/how-does-sw-precache-works-2d99c3d3c725&quot;&gt;how SW-Precache works&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;In fact, we only collect dependencies of routes we flagged as “Critical Route”.&lt;/strong&gt; You can think of them as &lt;a href=&quot;https://developers.google.com/web/updates/2015/11/app-shell&quot;&gt;“App Shell”&lt;/a&gt; or the “Installation Package” of our app. Once they are cached/installed successfully, our web app can boot up directly from cache and available offline. Routes that “not critical” would be incrementally cached at runtime during the first visit. Thanks to the LRU cache policies and TTL invalidation mechanisms provided by &lt;a href=&quot;https://googlechrome.github.io/sw-toolbox/&quot;&gt;SW-Toolbox&lt;/a&gt;, we have no worries of hitting the quota in a long run.&lt;/p&gt;

&lt;h3 id=&quot;4-lazy-load--instantiate-remaining-routes-on-demand&quot;&gt;4. LAZY-load &amp;amp; instantiate remaining routes on demand&lt;/h3&gt;

&lt;p&gt;Lazy-loading and lazily instantiating remaining parts of the app is relatively challenging for SPA to achieve. It requires both code splitting and async importing. Fortunately, this is also a built-in feature of MPA model, in which routes are naturally separated.&lt;/p&gt;

&lt;p&gt;Noticed that the lazy-loading can be done instantly if the requested route is already pre-cached in Service Worker cache, no matter whether SPA or MPA is used. #ServiceWorkerAwesomeness&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Surprisingly, we found Multi-page PWA is kinda naturally “PRPL”! MPA has already provided built-in support for “PRL”, and the second “P” involving Service Worker can be easily fulfilled in any PWA.&lt;/p&gt;

&lt;p&gt;So what about the end result?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-eleme-pwa/Lighthouse-before.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;In &lt;a href=&quot;https://developers.google.com/web/tools/lighthouse/&quot;&gt;Lighthouse&lt;/a&gt; simulation (3G &amp;amp; 5x Slower CPU), we made Time-To-Interactive around 2 seconds,&lt;/strong&gt; and this was benchmarked on our HTTP1 test server.&lt;/p&gt;

&lt;p&gt;The first visit is fast. The repeat visit with Service Worker is even faster. You can check out this video to see the huge difference between with or without Service Worker:&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/mbi_WnunJa8&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;Did you see that? No, I mean the annoying blank screen. Even in the Service Worker one, the blank screen is still conspicuous during navigating. How can that be?&lt;/p&gt;

&lt;h2 id=&quot;multi-page-pitfall-redo-everything&quot;&gt;Multi-page Pitfall: Redo Everything!&lt;/h2&gt;

&lt;p&gt;Unlike SPA, changing routes in MPA means actual browser navigation happens: The previous page is discarded completely and the browser need to redo everything for next route: re-download resources, re-parse HTML, re-evaluate JavaScript, re-decode image data, re-layout the page and re-paint the screen, even many of them could be shared across routes. All of these works combined requires significant computing and time.&lt;/p&gt;

&lt;p&gt;So here is the profile (2x slower CPU simulated) of our entry page (most heavy one). Even we can make Time-To-Interactive around 1s in repeat visit, our users can still feel too slow for just “switching a tab”.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-eleme-pwa/msite-Before-Optim.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;huge-javascript-re-startup-cost&quot;&gt;Huge JavaScript Re-Startup Cost&lt;/h3&gt;

&lt;p&gt;According to the profile, most of the time (900ms) before hitting the first paint is spent on evaluating JavaScript. Half is on dependencies including Vue Runtime, components, libraries etc., another half is on actual Vue starting-up and mounting. Because all UI rendering is depended on JavaScript/Vue, all of the critical scripts remain guiltily parser-blocking. I’m by no means blaming JavaScript or Vue’s overheads here, It’s just a tradeoff when we need this layer of abstraction in engineering.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;In SPA, JavaScript Start-up Cost is amortized during the whole lifecycle.&lt;/strong&gt; Parsing/Compiling for each script is only once, many heavy executing can be only once. The big JavaScript objects like Vue’s ViewModels and Virtual DOM can be kept in memory and reused as much as you want. &lt;strong&gt;This is not the case in MPA however.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;could-browser-caches-help&quot;&gt;Could Browser Caches Help?&lt;/h3&gt;

&lt;p&gt;Yes or no.&lt;/p&gt;

&lt;p&gt;V8 introduced &lt;a href=&quot;http://v8project.blogspot.com/2015/07/code-caching.html&quot;&gt;code caching&lt;/a&gt;, a way to store a local copy of compiled code so fetching, parsing and compilation could all be skipped next time. As @addyosmani mentioned in &lt;a href=&quot;https://medium.com/reloading/javascript-start-up-performance-69200f43b201&quot;&gt;JavaScript Start-up Performance&lt;/a&gt;, scripts stored in Cache Storage via Service Worker could trigger code caching in just the first execution.&lt;/p&gt;

&lt;p&gt;Another browser cache you might hear of is “Back-Forward Cache”, or bfcache. The name varies, like Opera’s “Fast History Navigation” or &lt;a href=&quot;https://webkit.org/blog/427/webkit-page-cache-i-the-basics/&quot;&gt;WebKit’s “Page Cache”&lt;/a&gt;. &lt;strong&gt;The idea is that browsers can keep the previous page live in memory, i.e. DOM/JS states, instead of destroying everything.&lt;/strong&gt; In fact, this idea works very well for MPA. You can try every traditional Multi-page websites in iOS Safari and observe an instantaneously loading when back/forward. (With browser UI/Gesture or with hyperlink can have a slight difference though.)&lt;/p&gt;

&lt;p&gt;Unfortunately, Chrome has no this kind of in-memory bfcache currently concerning to memory consumption and its multi-process architecture. It just leverages HTTP disk cache to simplify the loading pipeline, almost everything still needs to be redone. More details and discussions can be seen &lt;a href=&quot;https://docs.google.com/document/d/1o8KImLPrJQcMNqvd_a-1V8fEVgtVeEJww453ZQ1hGuo/edit#&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;striving-for-perceived-performance&quot;&gt;Striving for Perceived Performance&lt;/h2&gt;

&lt;p&gt;Although the reality is dark, we don’t want to give up so easily. One optimization we try to do is to render DOM nodes/create Virtual DOM nodes as less as possible to improve the Time-To-Interactive. While another opportunity we see is to play tricks on perceived performance.&lt;/p&gt;

&lt;p&gt;@owencm have written a great post &lt;a href=&quot;https://medium.com/@owencm/reactive-web-design-the-secret-to-building-web-apps-that-feel-amazing-b5cbfe9b7c50&quot;&gt;“Reactive Web Design: The secret to building web apps that feel amazing”&lt;/a&gt; covering both “Instant loads with skeleton screens” and “Stable loads via predefined sizes on elements” to improve perceived performance and user experience. Yes, we actually used both.&lt;/p&gt;

&lt;p&gt;What about we showing the end result after these optimizations first before entering technical nitty gritty? There you go!&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/K5JBGnMYO1s&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;Too fast and can not see the pulsing Skeleton Screen clearly? Here is a version showing how it looks like under 10 times slower CPU.&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/w1ZbNsHmRjs&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;This is a much better UX, right? Even we have slow navigation in slow devices, at least the UI is stable, consistent and always responding. So how we get there?&lt;/p&gt;

&lt;h3 id=&quot;rendering-skeleton-screen-with-vue-at-build-time&quot;&gt;Rendering Skeleton Screen with Vue at Build-Time&lt;/h3&gt;

&lt;p&gt;As you might have guessed, the Skeleton Screen that consists of markups, styles, and images is inlined into &lt;code class=&quot;highlighter-rouge&quot;&gt;*.html&lt;/code&gt; of each route. So they can be cached by Service Worker, be loaded instantly, and be rendered independently with any JavaScript.&lt;/p&gt;

&lt;p&gt;We don’t want to manually craft each Skeleton Screen for each routes. It’s a tedious job and we have to manually sync every change between Skeleton Screens and the actual UI components (Yes we treat every route as just a Vue component). But think about it, &lt;a href=&quot;https://www.lukew.com/ff/entry.asp?1797&quot;&gt;Skeleton Screen is just a blank version of a page into which information is gradually loaded&lt;/a&gt;. What if we bake the Skeleton Screen into the actual UI component as just a loading state so we can render Skeleton Screen out directly from it without the issue of syncing?&lt;/p&gt;

&lt;p&gt;Thanks to the versatility of Vue, we can actually realize it with &lt;a href=&quot;https://ssr.vuejs.org/en/&quot;&gt;Vue.js Server-Side Rendering&lt;/a&gt;. Instead of using it on a real server, we use it at build time to render Vue components to strings and injected them into HTML templates.&lt;/p&gt;

&lt;h3 id=&quot;fast-skeleton-painting&quot;&gt;Fast Skeleton Painting…&lt;/h3&gt;

&lt;p&gt;Having markups in &lt;code class=&quot;highlighter-rouge&quot;&gt;*.html&lt;/code&gt; doesn’t mean that they will be painted fast, you have to make sure the &lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/critical-rendering-path/&quot;&gt;Critical Rendering Path&lt;/a&gt; is optimized for that. Many developers believed that putting script tags in the end of the body is sufficient for getting content painted before executing scripts. This might be true for browsers supporting rendering an incomplete DOM tree (e.g. streaming render), But browsers might not do that in mobile concerning slower hardwares, battery, and heats. &lt;strong&gt;And even we are told that script tags with &lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;defer&lt;/code&gt; is not parser-blocking, it also doesn’t mean we can get content painted before executing scripts in reality.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://html.spec.whatwg.org/images/asyncdefer.svg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;First I want to clarify it a little bit. According to the &lt;a href=&quot;https://www.w3.org/TR/html51/semantics-scripting.html#elementdef-script&quot;&gt;Scripting section of HTML&lt;/a&gt; (WHATWG living standard, the W3C’s same here), &lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt; scripts would be evaluated as soon as it is available thus could potentially blocking parsing. Only &lt;code class=&quot;highlighter-rouge&quot;&gt;defer&lt;/code&gt; (and not inlined) is specified to be never block parsing. That’s why &lt;a href=&quot;http://stevesouders.com/&quot;&gt;Steve Souders&lt;/a&gt; ever posted &lt;a href=&quot;https://calendar.perfplanet.com/2016/prefer-defer-over-async/&quot;&gt;“Prefer DEFER Over ASYNC”&lt;/a&gt;. (&lt;code class=&quot;highlighter-rouge&quot;&gt;defer&lt;/code&gt; has its own issue and we will cover it later.)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Then I want to say: A script not blocking parser could still block painting nonetheless.&lt;/strong&gt; So here is a reduced test I wrote named &lt;strong&gt;“Minimal Multi-page PWA”&lt;/strong&gt;, or MMPWA, which basically render 1000 list items within an &lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt; (and truly not parser-blocking) script to see if we can get Skeleton Screen painted before scripts get executed. The profile below (over USB debugging on my real Nexus 5) shows my ignorance:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-eleme-pwa/thisTick-&amp;amp;-Load.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Yes, keep your mouth open. The first paint is blocked. I was also surprised here. The reason I guess is that &lt;strong&gt;if we touch DOM so quickly that the browser has still NOT finished previous painting job, our dear browser has to abort every pixel it has drawn, and has to wait until current DOM manipulation task finished and redo the rendering pipeline again.&lt;/strong&gt; And this more often happens with a mobile device with a slower CPU/GPU.&lt;/p&gt;

&lt;h3 id=&quot;fast-skeleton-painting-with-settimeout-hack&quot;&gt;Fast Skeleton Painting with setTimeout Hack&lt;/h3&gt;

&lt;p&gt;We indeed encountered this problem when testing our new beautiful Skeleton Screen. Perhaps Vue finishes its job and start to mount nodes too fast ;). But anyway we have to make it slower, or rather lazier. So we try to put DOM manipulation things inside &lt;code class=&quot;highlighter-rouge&quot;&gt;setTimeout(callback, 0)&lt;/code&gt;, and it works like a charm!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-eleme-pwa/nextTick-&amp;amp;-Load.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I think you may curious about how this change performs in the wild, so I have refined MMPWA by rendering 5000 list items rather 1000 to make the differences more obvious, and by designing it in an A/B testing manner. The code is on &lt;a href=&quot;https://github.com/Huxpro/mmpwa&quot;&gt;Github&lt;/a&gt; and the demo is live on &lt;a href=&quot;https://huangxuan.me/mmpwa&quot;&gt;huangxuan.me/mmpwa/&lt;/a&gt;. Here is also a video for loungers.&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/3Ws7XBHrPD8&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;This famous &lt;code class=&quot;highlighter-rouge&quot;&gt;setTimeout&lt;/code&gt; hack (a.k.a. Zero Delays) looks quite magic,  but it is science™. If you are familiar with &lt;strong&gt;event loop&lt;/strong&gt;, it just prevents these code from executing in the current loop by putting everything to the &lt;strong&gt;task queues&lt;/strong&gt; with the Timer Callback, so the browser could breath (update the rendering) in the main thread.&lt;/p&gt;

&lt;p&gt;So we applied what we learned from MMPWA by putting &lt;code class=&quot;highlighter-rouge&quot;&gt;new Vue()&lt;/code&gt; inside &lt;code class=&quot;highlighter-rouge&quot;&gt;setTimeout&lt;/code&gt; and BOOM! We have Skeleton Screen painted consistently after every navigating! Here is the profile after all these optimizations.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-eleme-pwa/msite-After-Optim.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Huge improvements right?  This time we hit First Paint (Skeleton Screen Paint) at 400ms and TTI at 600ms. You should really go back to have a before-after comparison in details.&lt;/p&gt;

&lt;h3 id=&quot;one-more-thing-that-ideferred&quot;&gt;One more thing that I deferred&lt;/h3&gt;

&lt;p&gt;But wait, why is there still a bunch of guiltily parser-blocking scripts? Are them all &lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt;? OK, ok. For historical reasons, we do keep some parser-blocking scripts, like &lt;a href=&quot;https://github.com/amfe/lib-flexible&quot;&gt;lib-flexible&lt;/a&gt;, we couldn’t get rid of it without a huge refactoring. But most of these blocking scripts are in fact &lt;code class=&quot;highlighter-rouge&quot;&gt;defer&lt;/code&gt;. We expected that they can be executed after parsing and in order, however the profile kinda slap on my face. :(&lt;/p&gt;

&lt;p&gt;Remember I said I would talk about one issue of &lt;code class=&quot;highlighter-rouge&quot;&gt;defer&lt;/code&gt; previously? Yes, that’s it. I have had a &lt;a href=&quot;https://twitter.com/Huxpro/status/859842124849827841&quot;&gt;conversation&lt;/a&gt; with &lt;a href=&quot;https://twitter.com/jaffathecake&quot;&gt;Jake Archibald&lt;/a&gt; and it turns out it might be a bug of Chrome when the deferred scripts are fully cached. &lt;a href=&quot;https://bugs.chromium.org/p/chromium/issues/detail?id=717979&quot;&gt;Vote it at crbug&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;Similar improvements can be seen from Lighthouse (Under same server and network environment). A Pro Tip is you should always use lighthouse in a variable controlling approach.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-eleme-pwa/Lighthouse-after.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;performance-in-the-real-world&quot;&gt;Performance In the Real World&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://medium.com/@slightlylate&quot;&gt;Alex Russell&lt;/a&gt; has given &lt;a href=&quot;https://youtu.be/4bZvq3nodf4?list=PLNYkxOF6rcIBTs2KPy1E6tIYaWoFcG3uj&quot;&gt;a very insightful talk on mobile web performance&lt;/a&gt; at Chrome Dev Summit 2016, talking about how hard can we build performant web applications on mobile devices. Highly recommended.&lt;/p&gt;

&lt;p&gt;Chinese users tend to have a pretty powerful phone. MI4 is shipped with snapdragon 801 (slightly out-performs Nexus 5) but only costs 100$. It’s affordable by at least 80% of our users so we take it as a baseline.&lt;/p&gt;

&lt;p&gt;Here is a video screen-recorded on my Nexus 5 showing switching between 4 tabs. The performance varies between tabs due to their variant scale. The heaviest one, entry page, take around 1s to hit real Time-To-Interactive on my Nexus 5.&lt;/p&gt;

&lt;p&gt;FYI. This is surprisingly comparable to what I get from Chrome Simulation with 2x CPU throttling. With 5x throttling, this can spend 2–3s to get TTI, horribly. (To be honest, I found even under same throttling, the results can vary drastically depended on my Macbook’s “mood”.)&lt;/p&gt;

&lt;iframe width=&quot;700&quot; height=&quot;525&quot; src=&quot;https://www.youtube.com/embed/ZLc8jysMqaw?ecver=1&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;This article is much longer than I could imagine. I am really appreciated if you could get here. So what can we learn from it?&lt;/p&gt;

&lt;h3 id=&quot;mpa-still-has-some-way-to-go&quot;&gt;MPA still has some way to go&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://twitter.com/jaffathecake&quot;&gt;Jake Archibald&lt;/a&gt; ever said that “PWA !== SPA” at &lt;a href=&quot;https://youtu.be/J2dOTKBoTL4?list=PLNYkxOF6rcIBTs2KPy1E6tIYaWoFcG3uj&quot;&gt;Chrome Dev Summit 2016&lt;/a&gt;. But the sad truth is that even we have taken advantages of bleeding edge technologies such as “PRPL” pattern, Service Worker, App-Shell, Skeleton Screen, there is still a distance between us and many Single Page PWA just because we are Multi-page structured.&lt;/p&gt;

&lt;p&gt;The web is extremely versatile. Static blogs, e-business sites, desktop-level software, all of them should be the first-class citizens of the web family. MPA might have things like “bfcache API”, navigation transitions to catch up the SPA in the future, but it is not today certainly.&lt;/p&gt;

&lt;h3 id=&quot;pwa-is-awesome-no-matter-what&quot;&gt;PWA is Awesome No Matter What&lt;/h3&gt;

&lt;p&gt;Hey, I am not overblowing it. Even we as a Multi-page PWA couldn’t be as stunning and app-like as many Single Page PWAs are. The idea and technologies behind PWA still help us deliver a much better experience to our users on the web that hasn’t been possible before.&lt;/p&gt;

&lt;p&gt;What PWA is trying to solve are some fundamental problems of current web application model such as its hard dependencies to network and browser UIs. That’ why PWA can be always beneficial no matter what architecture or what framework you actually used. &lt;a href=&quot;https://medium.com/@addyosmani&quot;&gt;Addy Osmani&lt;/a&gt; would give a talk &lt;a href=&quot;https://events.google.com/io/schedule/?section=may-19&amp;amp;sid=e8436b55-ea89-4243-a644-5ecb319d9ef0&quot;&gt;Production Progressive Web Apps With JavaScript Frameworks&lt;/a&gt; at this year’s I/O (and &lt;a href=&quot;https://youtu.be/srdKq0DckXQ?list=PLNYkxOF6rcIDz1TzmmMRBC-kd8zPRTQIP&quot;&gt;I/O 16&lt;/a&gt;). You won’t want to miss it!&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Finally, I’d love to thank:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;my colleagues &lt;a href=&quot;https://github.com/YiSiWang&quot;&gt;YiSi Wang&lt;/a&gt;, &lt;a href=&quot;https://github.com/rguanghui&quot;&gt;GuangHui Ren&lt;/a&gt;, &lt;a href=&quot;https://medium.com/@jiyinyiyong&quot;&gt;JiyinYiyong&lt;/a&gt; from Eleme&lt;/li&gt;
  &lt;li&gt;collaborator &lt;a href=&quot;https://medium.com/@micyeung&quot;&gt;Michael Yeung&lt;/a&gt;, &lt;a href=&quot;https://medium.com/@LiamSpradlin&quot;&gt;Liam Spradlin&lt;/a&gt; and other collaborators from Google&lt;/li&gt;
  &lt;li&gt;collaborators from UC/Tencent&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And special thanks to &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;invited reviewer, &lt;a href=&quot;https://medium.com/@youyuxi&quot;&gt;Evan You&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;Chrome “StackOverflow”, &lt;a href=&quot;https://twitter.com/jaffathecake&quot;&gt;Jake Archibald&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Thank you all!&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;appendix-architecture-diagram&quot;&gt;Appendix. Architecture Diagram&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-eleme-pwa/Architecture.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;


&lt;/div&gt;
</description>
        <pubDate>Wed, 12 Jul 2017 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/07/12/upgrading-eleme-to-pwa/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/07/12/upgrading-eleme-to-pwa/</guid>
        
        <category>Web</category>
        
        <category>PWA</category>
        
        
      </item>
    
      <item>
        <title>他是狗，你们便是苟奴隶</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;在知乎被删帖，我理解知乎。&lt;br /&gt;
你说你们做不了什么，我也理解你们。&lt;br /&gt;
&lt;br /&gt;
只是，总要有人，还敢说点反对的声音吧？  &lt;br /&gt;
只是，不想让这一切，看起来都变得如此理所应当吧？&lt;br /&gt;
&lt;br /&gt;
你说，你们也抗争了&lt;br /&gt;
那就站出来，让我们相信，你们还在吧？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我甚至都不需要写出 LGL 三个顶天立地的大字，你们便知道我今天要说什么了。
骂狗官、骂体制、骂 D，骂的人已经够多了。我故是可以再骂，却也深知自己甚至连让他们听到这份声音的能力都没有。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;但今天，我要骂的是你们，至少还能听到我声音的你们。&lt;/strong&gt; 我亲爱的同行们啊，那些在微博、知乎与其他社交网络公司工作的你们啊。无论你是我推心置腹的好友，相识或共事过的伙伴，还是素未谋面的陌生人，对不起，今天我要骂的就是你们。&lt;/p&gt;

&lt;p&gt;微博，「随时随地发现新鲜事」，这世界 TM 还只能发生你审核过的新鲜事了？&lt;/p&gt;

&lt;p&gt;知乎，「发现更大的世界」，我 TM 还只能发现你审核过的世界了？&lt;/p&gt;

&lt;p&gt;好一个又一个讲着漂亮故事的互联网公司啊，你们不是打着 UGC、言论开放的旗号、沾着民智渐开，民主自由的福利吗？好一个又一个独立自强、新时代的互联网员工啊，你们不是为「建设了中国互联网」，打造了一个「用户喜爱的产品」而感到自豪吗？&lt;/p&gt;

&lt;p&gt;嘴上说着不要，身体却已经跪在金钱与权势之下任人驱使了嘛。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;奴隶，通常指失去人身自由并被他人任意驱使的，为他们做事的人。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;这种情况，我们一般称之为「奴隶」。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;你可以跟我喊冤，说你也想反抗过，说你也很无奈。说你也思考过政府和媒体的关系，说你也知道权利、体制的可怖与强大，说你不能承担反抗的后果。&lt;/p&gt;

&lt;p&gt;可难道那些国乒远动员们不知道吗？从小成长在体制内的他们，比你清楚得多太多了。可是为了自己的权利、自己的公平，自己的爱，他们还是集体站出来了啊！他们直面着比你大得多的体制压力，承受着可能影响他们一生的严重后果。你告诉他们应该隐忍？识大体？沉默？那叫做苟且，叫做冷血，叫做向暴政与不公屈服！他们也知道，在体制面前他们势单力薄，可能是以卵击石头。他们不顾一切的发声，那是在请求我们的帮助啊！&lt;/p&gt;

&lt;p&gt;而你现在却还在问我你为什么要怪罪我，而不去怪罪那些「上面」的人？&lt;/p&gt;

&lt;p&gt;我当然也怪罪「上面」的人！但是你们，是你们！直接挡住了他们的求救，挡住了人民的援助，挡住了人民发声的渠道啊！传统媒体是 D 的喉舌，而你们呢，为自由奋斗的你们呢？你们本该成为人民的耳朵、眼睛和嘴啊，现在却愿意让人民都成为聋子、瞎子、哑巴了吗？&lt;/p&gt;

&lt;p&gt;你们或许觉得一己之力无法改变任何事情，于是沉默，每个人都沉默，仿佛罪恶都被平摊了，到每个人身上就都接近于 0 了。仿佛这一切就都理所应当了，可是真的就理所应当了吗？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一群人在作恶时，每个个体就不是在作恶了吗！？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;天再黑也要说话啊。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;我是一个胖球迷，从小就是。初中、高中、大学一路在校队打着酱油，参加一些业余的小比赛。很多人说在中国会打点胖球没什么稀奇，这是国球。很多人说打胖球不帅，女生们都围着打篮球的转。可是没办法，我就是喜欢，床头贴着 LGL 带着二王一马拿下世乒赛的海报，家里的《乒乓世界》一垛又一垛，一直到现在也不舍得扔。&lt;/p&gt;

&lt;p&gt;我是一个程序员，从小就是。在几家公司打过酱油，做过一些小分享。很多人说程序员都是农民，天天干一些重复的事情，加班多，死得早。可是没办法，我就是喜欢，喜欢互联网这个崇尚自由与平等的地方，欣赏那些用互联网让世界变得更加美好的人们。我不是为了谋生而选择了这个职业，我是为了自由与骄傲。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;We will not go quietly into the night! &lt;br /&gt;
We will not vanish without a fight! &lt;br /&gt;
We’re going to live on! &lt;br /&gt;
We’re going to survive! &lt;br /&gt;
Today, we celebrate our Independence Day!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;国乒，愿有属于你们的独立日。&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 24 Jun 2017 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/06/24/you-are-slaves/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/06/24/you-are-slaves/</guid>
        
        
      </item>
    
      <item>
        <title>How does SW-Precache works?</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://github.com/GoogleChrome/sw-precache&quot;&gt;&lt;em&gt;SW-Precache&lt;/em&gt;&lt;/a&gt; &lt;em&gt;is a great Service Worker tool from Google. It is a node module designed to be&lt;/em&gt; &lt;em&gt;integrated&lt;/em&gt; &lt;em&gt;into your build process and to generate a service worker for you.&lt;/em&gt; &lt;em&gt;Though&lt;/em&gt; &lt;em&gt;you can use sw-precache out of the box, you might still wonder what happens under the hood. There you go, this article is written for you!&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;This post was first published at &lt;a href=&quot;https://medium.com/@Huxpro/how-does-sw-precache-works-2d99c3d3c725&quot;&gt;Medium&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;p&gt;The core files involving in sw-precache are mainly three:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;service-worker.tmpl  
lib/  
 ├ sw-precache.js  
 └ functions.js
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sw-precache.js&lt;/code&gt; is the main entry of the module. It reads the configuration, processes parameters, populates the &lt;code class=&quot;highlighter-rouge&quot;&gt;service-worker.tmpl&lt;/code&gt; template and writes the result into specified file. And&lt;code class=&quot;highlighter-rouge&quot;&gt;functions.js&lt;/code&gt; is just a module containing bunch of external functions which would be all injected into the generated service worker file as helpers.&lt;/p&gt;

&lt;p&gt;Since the end effect of sw-precache is performed by the generated service worker file in the runtime, a easy way to get an idea of what happens is by checking out source code inside &lt;code class=&quot;highlighter-rouge&quot;&gt;service-worker.tmpl&lt;/code&gt; . It’s not hard to understand the essentials and I will help you.&lt;/p&gt;

&lt;h2 id=&quot;initialization&quot;&gt;Initialization&lt;/h2&gt;

&lt;p&gt;The generated service worker file (let’s call it &lt;code class=&quot;highlighter-rouge&quot;&gt;sw.js&lt;/code&gt; for instance) get configuration by text interpolation when &lt;code class=&quot;highlighter-rouge&quot;&gt;sw-precache.js&lt;/code&gt; populating &lt;code class=&quot;highlighter-rouge&quot;&gt;service-worker.tmpl&lt;/code&gt; .&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// service-worker.tmpl  &lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;precacheConfig&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;%=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;precacheConfig&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// sw.js  &lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;precacheConfig&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;  
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;js/a.js&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;3cb4f0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;   
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;css/b.css&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;c5a951&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It’s not difficult to see that it’s a list of relative urls and MD5 hashes. In fact, one thing that &lt;code class=&quot;highlighter-rouge&quot;&gt;sw-precache.js&lt;/code&gt; do in the build time is to calculate hash of each file that it asked to “precache” from &lt;code class=&quot;highlighter-rouge&quot;&gt;staticFileGlobs&lt;/code&gt; parameter.&lt;/p&gt;

&lt;p&gt;In &lt;code class=&quot;highlighter-rouge&quot;&gt;sw.js&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;precacheConfig&lt;/code&gt; would be transformed into a ES6 Map with structure &lt;code class=&quot;highlighter-rouge&quot;&gt;Map {absoluteUrl =&amp;gt; cacheKey}&lt;/code&gt; as below. Noticed that I omit the origin part (e.g. &lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost&lt;/code&gt;) for short.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;urlToCacheKeys&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
  &lt;span class=&quot;s2&quot;&gt;&quot;http.../js/a.js&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;http.../js/a.js?_sw-precache=3cb4f0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;   
  &lt;span class=&quot;s2&quot;&gt;&quot;http.../css/b.js&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;http.../css/b.css?_sw-precache=c5a951&quot;&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Instead of using raw URL as the cache key, sw-precache append a &lt;code class=&quot;highlighter-rouge&quot;&gt;_sw-precache=[hash]&lt;/code&gt; to the end of each URL when populating, updating its cache and even fetching these subresouces. Those &lt;code class=&quot;highlighter-rouge&quot;&gt;_sw-precache=[hash]&lt;/code&gt; are what we called &lt;strong&gt;cache-busting parameter*&lt;/strong&gt;. It can prevent service worker from responding and caching out-of-date responses found in browsers’ HTTP cache indefinitely.&lt;/p&gt;

&lt;p&gt;Because each build would re-calculate hashes and re-generate a new &lt;code class=&quot;highlighter-rouge&quot;&gt;sw.js&lt;/code&gt; with new &lt;code class=&quot;highlighter-rouge&quot;&gt;precacheConfig&lt;/code&gt; containing those new hashes, &lt;code class=&quot;highlighter-rouge&quot;&gt;sw.js&lt;/code&gt; can now determine the version of each subresources thus decide what part of its cache needs a update. &lt;strong&gt;This is pretty similar with what we commonly do when realizing long-term caching with webpack or gulp-rev, to do a byte-diff ahead of runtime.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;*: Developer can opt out this behaviour with &lt;code class=&quot;highlighter-rouge&quot;&gt;dontCacheBustUrlsMatching&lt;/code&gt; option if they set HTTP caching headers right. More details on &lt;a href=&quot;https://jakearchibald.com/2016/caching-best-practices/&quot;&gt;Jake’s Post&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;on-install&quot;&gt;On Install&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;ServiceWorker gives you an install event. You can use this to get stuff ready, stuff that must be ready before you handle other events.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;During the &lt;code class=&quot;highlighter-rouge&quot;&gt;install&lt;/code&gt; lifecycle, &lt;code class=&quot;highlighter-rouge&quot;&gt;sw.js&lt;/code&gt; open the cache and get started to populate its cache. One cool thing that it does for you is its &lt;strong&gt;incremental update&lt;/strong&gt; mechanism.&lt;/p&gt;

&lt;p&gt;Sw-precache would search each cache key (the values of &lt;code class=&quot;highlighter-rouge&quot;&gt;urlsToCacheKeys&lt;/code&gt;) in the &lt;code class=&quot;highlighter-rouge&quot;&gt;cachedUrls&lt;/code&gt;, a ES6 Set containing URLs of all requests indexed from current version of cache, and only &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;cache.put&lt;/code&gt; resources couldn’t be found in cache, i.e, never be cached before, thus reuse cached resources as much as possible.&lt;/p&gt;

&lt;p&gt;If you can not fully understand it, don’t worry. We will recap it later, now let’s move on.&lt;/p&gt;

&lt;h2 id=&quot;on-activate&quot;&gt;On Activate&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Once a new ServiceWorker has installed &amp;amp; a previous version isn’t being used, the new one activates, and you get an &lt;code class=&quot;highlighter-rouge&quot;&gt;activate&lt;/code&gt; event. Because the old version is out of the way, it’s a good time to handle schema migrations in IndexedDB and also delete unused caches.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;During activation phase, &lt;code class=&quot;highlighter-rouge&quot;&gt;sw.js&lt;/code&gt; would compare all existing requests in the cache, named &lt;code class=&quot;highlighter-rouge&quot;&gt;existingRequests&lt;/code&gt; (noticed that it now contains resources just cached on installation phase) with &lt;code class=&quot;highlighter-rouge&quot;&gt;setOfExpectedUrls&lt;/code&gt;, a ES6 Set from the values of &lt;code class=&quot;highlighter-rouge&quot;&gt;urlsToCacheKeys&lt;/code&gt;. And delete any requests not matching from cache.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// sw.js&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;existingRequests&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;existingRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setOfExpectedUrls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;has&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;existingRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;existingRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;on-fetch&quot;&gt;On Fetch&lt;/h2&gt;

&lt;p&gt;Although the comments in source code have elaborated everything well, I wanna highlight some points during the request intercepting duration.&lt;/p&gt;

&lt;h3 id=&quot;should-respond&quot;&gt;Should Respond?&lt;/h3&gt;

&lt;p&gt;Firstly, we need to determine whether this request was included in our “pre-caching list”. If it was, this request should have been pre-fetched and pre-cached thus we can respond it directly from cache.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// sw.js*  &lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;url&lt;/span&gt;      
&lt;span class=&quot;nx&quot;&gt;shouldRespond&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;urlsToCacheKeys&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;has&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Noticed that we are matching raw URLs (e.g. &lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost/js/a.js&lt;/code&gt;) instead of the hashed ones. It prevent us from calculating hashes at runtime, which would have a significant cost. And since we have kept the relationship in &lt;code class=&quot;highlighter-rouge&quot;&gt;urlToCacheKeys&lt;/code&gt; it’s easy to index the hashed one out.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;* In real cases, sw-precache would take &lt;code class=&quot;highlighter-rouge&quot;&gt;ignoreUrlParametersMatching&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;directoryIndex&lt;/code&gt; options into consideration.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;navigation-fallback&quot;&gt;Navigation Fallback&lt;/h3&gt;

&lt;p&gt;One interesting feature that sw-precache provided is &lt;code class=&quot;highlighter-rouge&quot;&gt;navigationFallback&lt;/code&gt;(previously &lt;code class=&quot;highlighter-rouge&quot;&gt;defaultRoute&lt;/code&gt;), which detect navigation request and respond a preset fallback HTML document when the URL of navigation request did not exist in &lt;code class=&quot;highlighter-rouge&quot;&gt;urlsToCacheKeys&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;It is presented for SPA using History API based routing, allowing responding arbitrary URLs with one single HTML entry defined in &lt;code class=&quot;highlighter-rouge&quot;&gt;navigationFallback&lt;/code&gt;, kinda reimplementing a Nginx rewrite in service worker*. Do noticed that service worker only intercept document (navigation request) inside its scope (and any resources referenced in those documents of course). So navigation towards outside scope would not be effected.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;* &lt;code class=&quot;highlighter-rouge&quot;&gt;navigateFallbackWhitelist&lt;/code&gt; can be provided to limit the “rewrite” scope.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;respond-fromcache&quot;&gt;Respond from Cache&lt;/h3&gt;

&lt;p&gt;Finally, we get the appropriate cache key (the hashed URL) by raw URL with &lt;code class=&quot;highlighter-rouge&quot;&gt;urlsToCacheKeys&lt;/code&gt; and invoke &lt;code class=&quot;highlighter-rouge&quot;&gt;event.respondWith()&lt;/code&gt; to respond requests from cache directly. Done!&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// sw.js*&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;respondWith&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;caches&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cacheName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cache&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;match&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;urlsToCacheKeys&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;response&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;* The code was “ES6-fied” with error handling part removed.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;cache-management-recap&quot;&gt;Cache Management Recap&lt;/h2&gt;

&lt;p&gt;That’s recap the cache management part with a full lifecycle simulation.&lt;/p&gt;

&lt;h3 id=&quot;the-firstbuild&quot;&gt;The first build&lt;/h3&gt;

&lt;p&gt;Supposed we are in the very first load, the &lt;code class=&quot;highlighter-rouge&quot;&gt;cachedUrls&lt;/code&gt; would be a empty set thus all subresources listed to be pre-cached would be fetched and put into cache on SW install time.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// cachedUrls  &lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// urlToCacheKeys  &lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
  &lt;span class=&quot;s2&quot;&gt;&quot;http.../js/a.js&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;http.../js/a.js?_sw-precache=3cb4f0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;   
  &lt;span class=&quot;s2&quot;&gt;&quot;http.../css/b.js&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;http.../css/b.css?_sw-precache=c5a951&quot;&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// SW Network Logs  &lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;GET&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;js&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_sw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;precache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cb4f0&lt;/span&gt;      
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;GET&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;css&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_sw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;precache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;c5a951&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;After that, it will start to control the page immediately because the &lt;code class=&quot;highlighter-rouge&quot;&gt;sw.js&lt;/code&gt; would call &lt;code class=&quot;highlighter-rouge&quot;&gt;clients.claim()&lt;/code&gt; by default. It means the &lt;code class=&quot;highlighter-rouge&quot;&gt;sw.js&lt;/code&gt; will start to intercept and try to serve future fetches from caches, so it’s good for performance.&lt;/p&gt;

&lt;p&gt;In the second load, all subresouces have been cached and will be served directly from cache. So none requests are sent from &lt;code class=&quot;highlighter-rouge&quot;&gt;sw.js&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// cachedUrls  &lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
  &lt;span class=&quot;s2&quot;&gt;&quot;http.../js/a.js? _sw-precache=3cb4f0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;   
  &lt;span class=&quot;s2&quot;&gt;&quot;http.../css/b.css? _sw-precache=c5a951&quot;&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// urlToCacheKeys  &lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
  &lt;span class=&quot;s2&quot;&gt;&quot;http.../js/a.js&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;http.../js/a.js? _sw-precache=3cb4f0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;   
  &lt;span class=&quot;s2&quot;&gt;&quot;http.../css/b.js&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;http.../css/b.css? _sw-precache=c5a951&quot;&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// SW Network Logs  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Empty&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;the-secondbuild&quot;&gt;The second build&lt;/h3&gt;

&lt;p&gt;Once we create a byte-diff of our subresouces (e.g., we modify &lt;code class=&quot;highlighter-rouge&quot;&gt;a.js&lt;/code&gt; to a new version with hash value &lt;code class=&quot;highlighter-rouge&quot;&gt;d6420f&lt;/code&gt;) and re-run the build process, a new version of &lt;code class=&quot;highlighter-rouge&quot;&gt;sw.js&lt;/code&gt; would be also generated.&lt;/p&gt;

&lt;p&gt;The new &lt;code class=&quot;highlighter-rouge&quot;&gt;sw.js&lt;/code&gt; would run alongside with the existing one, and start its own installation phase.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// cachedUrls  &lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
  &lt;span class=&quot;s2&quot;&gt;&quot;http.../js/a.js? _sw-precache=3cb4f0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;   
  &lt;span class=&quot;s2&quot;&gt;&quot;http.../css/b.css? _sw-precache=c5a951&quot;&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// urlToCacheKeys  &lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
  &lt;span class=&quot;s2&quot;&gt;&quot;http.../js/a.js&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;http.../js/a.js? _sw-precache=d6420f&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;   
  &lt;span class=&quot;s2&quot;&gt;&quot;http.../css/b.js&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;http.../css/b.css? _sw-precache=c5a951&quot;&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// SW Network Logs  &lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;GET&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;js&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_sw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;precache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;d6420f&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This time, &lt;code class=&quot;highlighter-rouge&quot;&gt;sw.js&lt;/code&gt; see that there is a new version of &lt;code class=&quot;highlighter-rouge&quot;&gt;a.js&lt;/code&gt; requested, so it fetch &lt;code class=&quot;highlighter-rouge&quot;&gt;/js/a.js?_sw-precache=d6420f&lt;/code&gt;  and put the response into cache. In fact, we have two versions of &lt;code class=&quot;highlighter-rouge&quot;&gt;a.js&lt;/code&gt; in cache at the same time in this moment.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// what's in cache?&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;js&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;js&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_sw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;precache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cb4f0&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;js&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;js&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_sw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;precache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;d6420f&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;css&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;css&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_sw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;precache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;c5a951&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;By default, &lt;code class=&quot;highlighter-rouge&quot;&gt;sw.js&lt;/code&gt; generated by sw-precache would call &lt;code class=&quot;highlighter-rouge&quot;&gt;self.skipWaiting&lt;/code&gt; so it would take over the page and move onto activating phase immediately.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// existingRequests&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;js&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;js&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_sw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;precache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cb4f0&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;js&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;js&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_sw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;precache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;d6420f&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;css&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;css&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_sw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;precache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;c5a951&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// setOfExpectedUrls&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;s2&quot;&gt;&quot;http.../js/a.js?_sw-precache=d6420f&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
  &lt;span class=&quot;s2&quot;&gt;&quot;http.../css/b.css?_sw-precache=c5a951&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// the one deleted&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;js&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;js&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_sw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;precache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cb4f0&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;By comparing existing requests in the cache with set of expected ones, the old version of &lt;code class=&quot;highlighter-rouge&quot;&gt;a.js&lt;/code&gt; would be deleted from cache. This ensure there is only one version of our site’s resources each time.&lt;/p&gt;

&lt;p&gt;That’s it! We finish the simulation successfully.&lt;/p&gt;

&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;As its name implied, sw-precache is designed specifically for the needs of precaching some critical static resources. It only does one thing but does it well. I’d love to give you some opinionated suggestions but you decide whether your requirements suit it or not.&lt;/p&gt;

&lt;h3 id=&quot;precaching-is-notfree&quot;&gt;Precaching is NOT free&lt;/h3&gt;

&lt;p&gt;So don’t precached everything. Sw-precache use a &lt;a href=&quot;https://jakearchibald.com/2014/offline-cookbook/#on-install-as-a-dependency&quot;&gt;“On Install — as a dependency”&lt;/a&gt; strategy for your precache configs. A huge list of requests would delay the time service worker finishing installing and, in addition, wastes users’ bandwidth and disk space.&lt;/p&gt;

&lt;p&gt;For instance, if you wanna build a offline-capable blogs. You had better not include things like &lt;code class=&quot;highlighter-rouge&quot;&gt;'posts/*.html&lt;/code&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;staticFileGlobs&lt;/code&gt;. It would be a huge disaster to data-sensitive people if you have hundreds of posts. Use a Runtime Caching instead.&lt;/p&gt;

&lt;h3 id=&quot;app-shell&quot;&gt;“App Shell”&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;A helpful analogy is to think of your App Shell as the code and resources that would be published to an app store for a native iOS or Android application.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Though I always consider that the term “App Shell” is too narrow to cover its actual usages now, It is widely used and commonly known. I personally prefer calling them &lt;strong&gt;“Web Installation Package”&lt;/strong&gt; straightforward because they can be truly installed into users’ disks and our web app can boot up directly from them in any network environments. The only difference between “Web Installation Package” and iOS/Android App is that we need strive to limit it within a reasonable size.&lt;/p&gt;

&lt;p&gt;Precaching is perfect for this kinda resources such as entry html, visual placeholders, offline pages etc., because they can be static in one version, small-sized, and most importantly, part of critical rendering path. We wanna put first meaningful paint ASAP to our user thus we precache them to eliminate HTTP roundtrip time.&lt;/p&gt;

&lt;p&gt;BTW, if you are using HTML5 Application Cache before, sw-precache is really a perfect replacement because it can cover nearly all use cases the App Cache provide.&lt;/p&gt;

&lt;h3 id=&quot;this-is-not-theend&quot;&gt;This is not the end&lt;/h3&gt;

&lt;p&gt;Sw-precache is just one of awesome tools that can help you build service worker. If you are planing to add some service worker power into your website, Don’t hesitate to checkout sw-toolbox, sw-helper (a new tool Google is working on) and many more from communities.&lt;/p&gt;

&lt;p&gt;That’s all. Wish you enjoy!&lt;/p&gt;
</description>
        <pubDate>Sun, 28 May 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/05/28/sw-precache/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/05/28/sw-precache/</guid>
        
        <category>Web</category>
        
        <category>PWA</category>
        
        <category>🇬🇧</category>
        
        
      </item>
    
      <item>
        <title>「知乎」如何理解 &lt;code&gt;document&lt;/code&gt; 对象是 &lt;code&gt;HTMLDocument&lt;/code&gt; 的实例？</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;这篇文章转载自&lt;a href=&quot;https://www.zhihu.com/question/57601873/answer/155685476&quot;&gt;我在知乎上的回答&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;谢邀。&lt;/p&gt;

&lt;p&gt;首先要理解的是 DOM 是 API，是一组无关编程语言的接口（Interfaces）而非实现（Implementation）。前端平时常说的 DOM 其实只是浏览器通过 ECMAScript（JavaScript）对 DOM 接口的一种实现。&lt;/p&gt;

&lt;p&gt;其次要知道的是，DOM 既是为 HTML 制定的，也是为 XML 制定的。而两者各有一些特异的部分，所以作为 DOM 标准基石的 DOM Level 1 其实分为 Core 与 HTML 两个部分。Core 定义了 fundamental interfaces 与 extended interfaces，分别是共用的基础接口与 「XML 拓展包」，而 HTML 部分则全都是「HTML 拓展包」。题主所问到的 Document 接口被定义在 Core 的 fundamental interfaces 中，而 HTMLDocument 接口则定义在 HTML 部分中，且「接口继承」于 Document。&lt;/p&gt;

&lt;p&gt;这种继承关系当然是可以在 JavaScript 的 DOM 实现中体现出来的：&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// document 是 HTMLDocument 的实例&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;HTMLDocument&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// document 的 [[prototype]] 指向 HTMLDocument 的原型&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;__proto__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;HTMLDocument&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// HTMLDocument 伪类继承于 Document &lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;HTMLDocument&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Document&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;HTMLDocument&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;__proto__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;至于 Document 与 HTMLDocument 这两个构造函数，跟 Array、Object 一样都是 built-in 的：&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Document&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;native&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;HTMLDocument&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;HTMLDocument&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;native&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;虽然是 native code，但一个有意思的现象是，这两个构造函数之间也是存在原型链的：&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// HTMLDocument 的 [[prototype]] 是指向 Document 的&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;HTMLDocument&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;__proto__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Document&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 同理&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;Document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;__proto__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Node&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;__proto__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;EventTarget&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其作用是实现对静态成员的继承。（ ES6 Class 的行为与此完全一致，但这个行为在更早之前就是这样了。）&lt;/p&gt;

&lt;p&gt;好了扯远了，总结一下，&lt;strong&gt;在 JavaScript 的 DOM 实现中&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;document 是 HTMLDocument 的实例&lt;/li&gt;
  &lt;li&gt;HTMLDocument 继承于 Document&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;留一个课后作业，有兴趣的话可以看看 Document.prototype 与 HTMLDocument.prototype 里分别都有什么？在不同浏览器里都试试。&lt;/p&gt;

&lt;p&gt;以上。&lt;/p&gt;
</description>
        <pubDate>Thu, 06 Apr 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/04/06/html-document/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/04/06/html-document/</guid>
        
        <category>Web</category>
        
        <category>知乎</category>
        
        
      </item>
    
  </channel>
</rss>
